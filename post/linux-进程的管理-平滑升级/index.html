<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>Linux 进程的管理 &amp; 平滑升级 - 弓长笔记</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="jincheng9" /><meta name="description" content="进程退出原因 我们在编程软件或使用软件时，经常遇到进程莫名退出的情况。从经验来看，异常退出的进程主要有两大类原因。 进程自身异常崩溃 进程退出很大" /><meta name="keywords" content="Hugo, theme, even" />






<meta name="generator" content="Hugo 0.101.0 with theme even" />


<link rel="canonical" href="http://blog.gongchang.me/post/linux-%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%AE%A1%E7%90%86-%E5%B9%B3%E6%BB%91%E5%8D%87%E7%BA%A7/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.b5a744db6de49a86cadafb3b70f555ab443f83c307a483402259e94726b045ff.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:title" content="Linux 进程的管理 &amp; 平滑升级" />
<meta property="og:description" content="进程退出原因 我们在编程软件或使用软件时，经常遇到进程莫名退出的情况。从经验来看，异常退出的进程主要有两大类原因。 进程自身异常崩溃 进程退出很大" />
<meta property="og:type" content="article" />
<meta property="og:url" content="http://blog.gongchang.me/post/linux-%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%AE%A1%E7%90%86-%E5%B9%B3%E6%BB%91%E5%8D%87%E7%BA%A7/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2022-02-13T23:09:31+08:00" />
<meta property="article:modified_time" content="2022-02-13T23:09:31+08:00" />

<meta itemprop="name" content="Linux 进程的管理 &amp; 平滑升级">
<meta itemprop="description" content="进程退出原因 我们在编程软件或使用软件时，经常遇到进程莫名退出的情况。从经验来看，异常退出的进程主要有两大类原因。 进程自身异常崩溃 进程退出很大"><meta itemprop="datePublished" content="2022-02-13T23:09:31+08:00" />
<meta itemprop="dateModified" content="2022-02-13T23:09:31+08:00" />
<meta itemprop="wordCount" content="3885">
<meta itemprop="keywords" content="" /><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Linux 进程的管理 &amp; 平滑升级"/>
<meta name="twitter:description" content="进程退出原因 我们在编程软件或使用软件时，经常遇到进程莫名退出的情况。从经验来看，异常退出的进程主要有两大类原因。 进程自身异常崩溃 进程退出很大"/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">弓长笔记</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">主页</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">全部文章</li>
      </a><a href="/about/">
        <li class="mobile-menu-item">关于</li>
      </a>
  </ul>

  


</nav>

  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">弓长笔记</a>
</div>





<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">主页</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">全部文章</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/about/">关于</a>
      </li>
  </ul>
</nav>

    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">Linux 进程的管理 &amp; 平滑升级</h1>

      <div class="post-meta">
        <span class="post-time"> 2022-02-13 </span>
        
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">Contents</h2>
  <div class="post-toc-content always-active">
    <nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#进程退出原因">进程退出原因</a>
          <ul>
            <li><a href="#进程自身异常崩溃">进程自身异常崩溃</a></li>
            <li><a href="#进程被系统杀死">进程被系统杀死</a></li>
            <li><a href="#被信号杀死">被信号杀死</a></li>
          </ul>
        </li>
        <li><a href="#程序自启动和监控">程序自启动和监控</a>
          <ul>
            <li><a href="#system-v-init">System V Init</a></li>
            <li><a href="#systemd">Systemd</a></li>
            <li><a href="#crontab">crontab</a></li>
            <li><a href="#supervisord">supervisord</a></li>
          </ul>
        </li>
        <li><a href="#如何无缝升级程序">如何无缝升级程序？</a>
          <ul>
            <li><a href="#nginx-的做法">Nginx 的做法</a></li>
            <li><a href="#c语言模仿实现平滑重启">C语言模仿实现平滑重启</a></li>
          </ul>
        </li>
        <li><a href="#平滑重启方法的对比">平滑重启方法的对比</a></li>
      </ul>
    </li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <h2 id="进程退出原因">进程退出原因</h2>
<p>我们在编程软件或使用软件时，经常遇到进程莫名退出的情况。从经验来看，异常退出的进程主要有两大类原因。</p>
<h3 id="进程自身异常崩溃">进程自身异常崩溃</h3>
<p>进程退出很大一部分原因是业务方自身的问题，比如：</p>
<ul>
<li>内存访问越界</li>
<li>非法指针</li>
<li>堆栈溢出</li>
<li>访问只读内存等等</li>
</ul>
<p>怎么找出具体原因呢？使用 core dump 即可。下面是开启 core dump 并且不限制 coredump 文件的大小。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">$ ulimit -c unlimited
</span></span></code></pre></td></tr></table>
</div>
</div><p>控制 core dump 文件生成名，默认是在执行程序路径下生成。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">$ cat /proc/sys/kernel/core_uses_pid  # 可以控制core文件的文件名中是否添加pid作为扩展。文件内容为1，表示添加pid作为扩展名，生成的 core文件格式为core.xxxx；为0则表示生成的core文件同一命名为core。
</span></span><span class="line"><span class="cl">1
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">$ cat /proc/sys/kernel/core_pattern    # 可以控制core文件保存位置和文件名格式。
</span></span><span class="line"><span class="cl">core
</span></span></code></pre></td></tr></table>
</div>
</div><p>接下来我们模拟程序异常，简单的读写 0 内存地址，就可以导致异常。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">#include &lt;stdio.h&gt;
</span></span><span class="line"><span class="cl">#include &lt;stdlib.h&gt;
</span></span><span class="line"><span class="cl">#include &lt;string.h&gt;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">int main(int argc, char * argv [ ])
</span></span><span class="line"><span class="cl">{
</span></span><span class="line"><span class="cl">    int *p = NULL;
</span></span><span class="line"><span class="cl">    *p = 0x12345678;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    return 0;
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>编译运行，注意要记录调试符号。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">$ gcc -g zero_memory.c
</span></span><span class="line"><span class="cl">$ ./a.out
</span></span><span class="line"><span class="cl">segment error(core dump)
</span></span></code></pre></td></tr></table>
</div>
</div><p>然后在当前程序目录下，生成了一个 core.64446 文件，我们用 gdb 调试这个文件。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">$ gdb ./a.out core.64446
</span></span><span class="line"><span class="cl">...
</span></span><span class="line"><span class="cl">Reading symbols from ./a.out...done.
</span></span><span class="line"><span class="cl">[New LWP 64446]
</span></span><span class="line"><span class="cl">Core was generated by `./a.out&#39;.
</span></span><span class="line"><span class="cl">Program terminated with signal SIGSEGV, Segmentation fault.
</span></span><span class="line"><span class="cl">#0  0x0000000000400656 in main (argc=1, argv=0x7ffc791435b8) at zero_memory.c:8
</span></span><span class="line"><span class="cl">18              *p = 123;
</span></span><span class="line"><span class="cl">Missing separate debuginfos, use: debuginfo-install glibc-2.17-325.el7_9.x86_64
</span></span><span class="line"><span class="cl">(gdb) bt
</span></span><span class="line"><span class="cl">#0  0x0000000000400656 in main (argc=1, argv=0x7ffc791435b8) at zero_memory.c:8
</span></span><span class="line"><span class="cl">(gdb) quit
</span></span></code></pre></td></tr></table>
</div>
</div><p>上面的命令可以看到，代码错误位置在 zero_memory.c 文件的第 8 行。然后我们修复后重新编译即可。</p>
<h3 id="进程被系统杀死">进程被系统杀死</h3>
<ul>
<li>因 OOM 被系统杀</li>
<li>被其它进程杀死</li>
</ul>
<p>如果进程内存超出限制，会被内核或者 cgroup 杀死，请查询 /var/log/dmesg 日志文件，或者通过 dmesg 命令找出 oom 详情。</p>
<p>cgroup 杀死进程的日志</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">$ dmesg | grep -i &#34;out of mem&#34;
</span></span><span class="line"><span class="cl">Memory cgroup out of memory: Kill process 1014588 (my-process) score 1974 or sacrifice child
</span></span></code></pre></td></tr></table>
</div>
</div><p>被系统 oom 杀死进程的日志</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">$ dmesg | grep -i &#34;out of mem&#34;
</span></span><span class="line"><span class="cl">[1471454.635492] Out of memory: Kill process 17907 (procon) score 143 or sacrifice child
</span></span><span class="line"><span class="cl">[1471454.636345] Killed process 17907 (procon) total-vm:5617060kB, anon-rss:4848752kB, file-rss:0kB
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="被信号杀死">被信号杀死</h3>
<p>当进程收到其它进程发来的 SIGKILL 或者 SIGTERM 信号也会退出。</p>
<p>如果我们想知道是谁发出的信号，可以借用 strace 定位是哪个进程给本进程发送什么信号，例如：</p>
<p>在终端窗口 1 执行：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">$ sleep 10000 &amp;
</span></span><span class="line"><span class="cl">[1] 6922
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">$ strace -tt -v -p 6922
</span></span><span class="line"><span class="cl">Process 6922 attached
</span></span><span class="line"><span class="cl">21:28:42.585287 restart_syscall(&lt;... resuming interrupted call ...&gt;) = ? ERESTART_RESTARTBLOCK (Interrupted by signal)
</span></span></code></pre></td></tr></table>
</div>
</div><p>在终端窗口 2 执行如下命令，杀死 sleep 进程：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl"># kill -15 6922
</span></span><span class="line"><span class="cl">[1] 6984
</span></span></code></pre></td></tr></table>
</div>
</div><p>终端窗口 1 显示：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">21:28:54.496291 --- SIGTERM {si_signo=SIGTERM, si_code=SI_USER, si_pid=6984, si_uid=0} ---
</span></span><span class="line"><span class="cl">21:28:54.496423 +++ killed by SIGTERM +++
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="程序自启动和监控">程序自启动和监控</h2>
<p>以下讨论都是基于 centos 系统，ubuntu、debian 大部分通用。</p>
<h3 id="system-v-init">System V Init</h3>
<p>这种方式是 centos7 之前的套路，为了完整性，我们还是介绍一下步骤，以 MySQL 为例。</p>
<ol>
<li>在 /etc/init.d 目录下建立相关程序的启动脚本，比如 mysqld</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">$ cat /etc/init.d/mysqld
</span></span><span class="line"><span class="cl"><span class="c1">#!/bin/sh</span>
</span></span><span class="line"><span class="cl">...
</span></span></code></pre></td></tr></table>
</div>
</div><ol start="2">
<li>在 /etc/rc.d/rc3.d/ 目录下创建终端启动模式下的自启动服务的软连接，我们可以通过 chkconfig 命令添加，先查看下目前有哪些。</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">$ ll /etc/rc.d/rc3.d/
</span></span><span class="line"><span class="cl">lrwxrwxrwx. 1 root root 20 12月 23 21:57 K50netconsole -&gt; ../init.d/netconsole
</span></span><span class="line"><span class="cl">lrwxrwxrwx. 1 root root 17 12月 23 21:57 S10network -&gt; ../init.d/network
</span></span><span class="line"><span class="cl"># K 开头代表不开启，S 开头代表开启
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">$ chkconfig --list # 列出服务列表
</span></span><span class="line"><span class="cl">...
</span></span><span class="line"><span class="cl">netconsole      0:off   1:off   2:off   3:off   4:off   5:off   6:off
</span></span><span class="line"><span class="cl">network         0:off   1:off   2:on    3:on    4:on    5:on    6:off
</span></span></code></pre></td></tr></table>
</div>
</div><ol start="3">
<li>使用 chkconfig 添加到开机自启服务列表</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">$ chkconfig --add mysqld  # 添加服务，默认在 2 3 4 5 级别开启
</span></span><span class="line"><span class="cl">$ chkconfig --del mysqld  # 删除服务
</span></span><span class="line"><span class="cl">$ chkconfig mysqld on # 开机服务在 2 3 4 5 级别
</span></span><span class="line"><span class="cl">$ chkconfig --list # 下面可看到，mysqld 已经开启
</span></span><span class="line"><span class="cl">mysqld          0:off   1:off   2:on    3:on    4:on    5:on    6:off
</span></span><span class="line"><span class="cl">netconsole      0:off   1:off   2:off   3:off   4:off   5:off   6:off
</span></span><span class="line"><span class="cl">network         0:off   1:off   2:on    3:on    4:on    5:on    6:off
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">$ ll /etc/rc.d/rc3.d/   # 再次查看启动脚本目录
</span></span><span class="line"><span class="cl">lrwxrwxrwx. 1 root root 20 Dec 23 21:57 K50netconsole -&gt; ../init.d/netconsole
</span></span><span class="line"><span class="cl">lrwxrwxrwx. 1 root root 17 Dec 23 21:57 S10network -&gt; ../init.d/network
</span></span><span class="line"><span class="cl">lrwxrwxrwx. 1 root root 16 Feb 22 11:14 S64mysqld -&gt; ../init.d/mysqld
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="systemd">Systemd</h3>
<p>上面可以做的，systemd 都可以实现，而且做的更好。</p>
<ul>
<li>开机启动启动程序；</li>
<li>也可以配置 start、stop、restart 管理程序；</li>
<li>可以用 cgroup 限制资源；</li>
<li>监控程序，如果退出自动重启。</li>
</ul>
<p>写一个伪 daemon 程序：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">#include &lt;stdio.h&gt;
</span></span><span class="line"><span class="cl">#include &lt;unistd.h&gt;
</span></span><span class="line"><span class="cl">#include &lt;sys/types.h&gt;
</span></span><span class="line"><span class="cl">#include &lt;sys/stat.h&gt;
</span></span><span class="line"><span class="cl">#include &lt;fcntl.h&gt;
</span></span><span class="line"><span class="cl">#include &lt;signal.h&gt;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">int fd;
</span></span><span class="line"><span class="cl">void sig_handler(int sig_no) {
</span></span><span class="line"><span class="cl">    if (sig_no == SIGTERM) {
</span></span><span class="line"><span class="cl">        write(fd, &#34;SIGTERM signo\n&#34;, 14);
</span></span><span class="line"><span class="cl">    } else if (sig_no == SIGHUP) {
</span></span><span class="line"><span class="cl">        write(fd, &#34;SIGHUP signo\n&#34;, 13);
</span></span><span class="line"><span class="cl">    } else {
</span></span><span class="line"><span class="cl">        write(fd, &#34;other signo\n&#34;, 12);
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">int main() {
</span></span><span class="line"><span class="cl">    //daemon(0, 0);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    int pid = fork();
</span></span><span class="line"><span class="cl">    if (pid == 0) {
</span></span><span class="line"><span class="cl">        signal(SIGTERM, sig_handler);
</span></span><span class="line"><span class="cl">        signal(SIGHUP, sig_handler);
</span></span><span class="line"><span class="cl">        fd = open(&#34;/tmp/mydaemon.log&#34;, O_RDWR | O_CREAT | O_APPEND, 0777);
</span></span><span class="line"><span class="cl">        while (1) {
</span></span><span class="line"><span class="cl">            write(fd, &#34;hello\n&#34;, 6);
</span></span><span class="line"><span class="cl">            sleep(3);
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">        close(fd);
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">    return 0;
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>编译程序，gcc mydaemon.c -o mydaemon，上面的程序主要就是</p>
<ul>
<li>每隔三秒往 /tmp/mydaemon.log 文件里写入日志信息</li>
<li>当收到信号时，打印信息到文件中</li>
</ul>
<p>配置我们的 service 脚本，</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">[Unit]
</span></span><span class="line"><span class="cl">Description=mydaemon
</span></span><span class="line"><span class="cl">After=network.target
</span></span><span class="line"><span class="cl"># StartLimitIntervalSec=0
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">[Service]
</span></span><span class="line"><span class="cl"># 环境变量
</span></span><span class="line"><span class="cl">Environment=&#39;MYDAEMON_HOME=abcdefg&#39;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">User=root
</span></span><span class="line"><span class="cl">Group=root
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">Type=forking
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"># Restart=always
</span></span><span class="line"><span class="cl"># RestartSec=1
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">ExecStart=/root/ctest/mydaemon
</span></span><span class="line"><span class="cl">ExecStop=/bin/kill -s TERM $MAINPID
</span></span><span class="line"><span class="cl">ExecReload=/bin/kill -s HUP $MAINPID
</span></span><span class="line"><span class="cl"># PrivateTmp=true
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">[Install]
</span></span><span class="line"><span class="cl">WantedBy=multi-user.target
</span></span></code></pre></td></tr></table>
</div>
</div><p>开启、停止、重启程序</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">$ systemctl restart mydaemon
</span></span><span class="line"><span class="cl">$ systemctl reload mydaemon
</span></span><span class="line"><span class="cl">$ systemctl stop mydaemon
</span></span></code></pre></td></tr></table>
</div>
</div><p>我们可以通过命令 tail -f  /tmp/mydaemon.log 查看文件内容。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">hello
</span></span><span class="line"><span class="cl">hello
</span></span><span class="line"><span class="cl">SIGHUP signo
</span></span><span class="line"><span class="cl">hello
</span></span><span class="line"><span class="cl">SIGTERM signo
</span></span><span class="line"><span class="cl">hello
</span></span></code></pre></td></tr></table>
</div>
</div><p>添加到开机自启动列表中</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">$ systemctl enable mydaemon
</span></span></code></pre></td></tr></table>
</div>
</div><p>执行完后，就会在 /etc/systemd/system/multi-user.target.wants/ 目录下新建一个指向 /usr/lib/systemd/system/mydaemon.service 文件的符号链接。</p>
<h3 id="crontab">crontab</h3>
<p>两种命令判断进程是否存在的办法：</p>
<ol>
<li>ps -ef | grep nginx | grep -v &ldquo;grep&rdquo; | wc -l</li>
<li>ps -C nginx &ndash;no-header | wc -l</li>
</ol>
<p>推荐用第二种，效率更高一点。写 shell 脚本判断程序是否正在运行。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl"><span class="cp">#!/bin/bash
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="nv">COUNT</span><span class="o">=</span><span class="k">$(</span>ps -C nginx --no-header <span class="p">|</span>wc -l<span class="k">)</span>
</span></span><span class="line"><span class="cl"><span class="k">if</span> <span class="o">[</span> <span class="nv">$COUNT</span> -eq <span class="m">0</span> <span class="o">]</span><span class="p">;</span> <span class="k">then</span>
</span></span><span class="line"><span class="cl">        <span class="nb">echo</span> NOT RUN
</span></span><span class="line"><span class="cl"><span class="k">else</span>
</span></span><span class="line"><span class="cl">        <span class="nb">echo</span> is RUN
</span></span><span class="line"><span class="cl"><span class="k">fi</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>添加到crontab里，</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">$ crontab -e
</span></span><span class="line"><span class="cl">* * * * * /usr/local/check.sh
</span></span></code></pre></td></tr></table>
</div>
</div><p>但这种办法太笨，一分钟才检查一次。而且还有个弊端，如果遇到同名进程，就会产生误判。所以使用这种方式检查需谨慎。</p>
<h3 id="supervisord">supervisord</h3>
<p>supervisord 是一个应用层的进程管理软件（配置比系统的更灵活），操作方法大概有：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">$ supervisorctl status
</span></span><span class="line"><span class="cl">$ supervisorctl stop tomcat
</span></span><span class="line"><span class="cl">$ supervisorctl start tomcat
</span></span><span class="line"><span class="cl">$ supervisorctl restart tomcat
</span></span><span class="line"><span class="cl">$ supervisorctl reread
</span></span><span class="line"><span class="cl">$ supervisorctl update
</span></span></code></pre></td></tr></table>
</div>
</div><p>要注意 supervisord 进程不能被其它信号意外杀死，可以用 systemd 管理 supervisord，而 supervisord 管理我们的应用进程。</p>
<h2 id="如何无缝升级程序">如何无缝升级程序？</h2>
<p>无缝升级程序的核心是，即使删除了程序文件，进程只要还在，文件资源在内核中就不会释放。所以我们可以：</p>
<ol>
<li>替换程序文件；</li>
<li>发送信号给进程，进程创建子进程并执行新的程序；</li>
<li>等到新进程初始化好后，关闭原来的进程。从而实现平滑的切换。</li>
</ol>
<h3 id="nginx-的做法">Nginx 的做法</h3>
<ol>
<li>发送 USR2 信号给 nginx 主进程</li>
<li>通过 fork、exec 执行一个新的 nginx 程序
<ul>
<li>注意，环境变量，命令行参数也要一并传递给新的 nginx 进程</li>
<li>环境变量里要带上一些标记，或者监听文件描述符 fd（除非能保证 fd 一定是 3，或者某一个特定的数字）</li>
<li>关闭自身监听文件描述符</li>
</ul>
</li>
<li>等待新 nginx 进程正常处理连接后，发送 QUIT 信号给旧 nginx 进程优雅停止。</li>
<li>nginx 的一些信号行为
<ul>
<li>HUP 重新加载配置文件，用新的配置文件启动新worker进程，并优雅的关闭旧的worker进程</li>
<li>QUIT 优雅退出，执行完当前的请求后退出</li>
<li>TERM 快速退出，当前的请求不执行完成就退出</li>
<li>INT 快速退出，当前的请求不执行完成就退出</li>
<li>USR1 重新打开日志文件，通常用在切换日志或切割日志文件中用到</li>
<li>USR2 平滑升级可执行进程，低版本升级为高版</li>
</ul>
</li>
</ol>
<h3 id="c语言模仿实现平滑重启">C语言模仿实现平滑重启</h3>
<p>我们为了简单，只实现两种信号功能，USR1，USR2。下面是一个完整的代码示例，接着是一些讲解。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">  1
</span><span class="lnt">  2
</span><span class="lnt">  3
</span><span class="lnt">  4
</span><span class="lnt">  5
</span><span class="lnt">  6
</span><span class="lnt">  7
</span><span class="lnt">  8
</span><span class="lnt">  9
</span><span class="lnt"> 10
</span><span class="lnt"> 11
</span><span class="lnt"> 12
</span><span class="lnt"> 13
</span><span class="lnt"> 14
</span><span class="lnt"> 15
</span><span class="lnt"> 16
</span><span class="lnt"> 17
</span><span class="lnt"> 18
</span><span class="lnt"> 19
</span><span class="lnt"> 20
</span><span class="lnt"> 21
</span><span class="lnt"> 22
</span><span class="lnt"> 23
</span><span class="lnt"> 24
</span><span class="lnt"> 25
</span><span class="lnt"> 26
</span><span class="lnt"> 27
</span><span class="lnt"> 28
</span><span class="lnt"> 29
</span><span class="lnt"> 30
</span><span class="lnt"> 31
</span><span class="lnt"> 32
</span><span class="lnt"> 33
</span><span class="lnt"> 34
</span><span class="lnt"> 35
</span><span class="lnt"> 36
</span><span class="lnt"> 37
</span><span class="lnt"> 38
</span><span class="lnt"> 39
</span><span class="lnt"> 40
</span><span class="lnt"> 41
</span><span class="lnt"> 42
</span><span class="lnt"> 43
</span><span class="lnt"> 44
</span><span class="lnt"> 45
</span><span class="lnt"> 46
</span><span class="lnt"> 47
</span><span class="lnt"> 48
</span><span class="lnt"> 49
</span><span class="lnt"> 50
</span><span class="lnt"> 51
</span><span class="lnt"> 52
</span><span class="lnt"> 53
</span><span class="lnt"> 54
</span><span class="lnt"> 55
</span><span class="lnt"> 56
</span><span class="lnt"> 57
</span><span class="lnt"> 58
</span><span class="lnt"> 59
</span><span class="lnt"> 60
</span><span class="lnt"> 61
</span><span class="lnt"> 62
</span><span class="lnt"> 63
</span><span class="lnt"> 64
</span><span class="lnt"> 65
</span><span class="lnt"> 66
</span><span class="lnt"> 67
</span><span class="lnt"> 68
</span><span class="lnt"> 69
</span><span class="lnt"> 70
</span><span class="lnt"> 71
</span><span class="lnt"> 72
</span><span class="lnt"> 73
</span><span class="lnt"> 74
</span><span class="lnt"> 75
</span><span class="lnt"> 76
</span><span class="lnt"> 77
</span><span class="lnt"> 78
</span><span class="lnt"> 79
</span><span class="lnt"> 80
</span><span class="lnt"> 81
</span><span class="lnt"> 82
</span><span class="lnt"> 83
</span><span class="lnt"> 84
</span><span class="lnt"> 85
</span><span class="lnt"> 86
</span><span class="lnt"> 87
</span><span class="lnt"> 88
</span><span class="lnt"> 89
</span><span class="lnt"> 90
</span><span class="lnt"> 91
</span><span class="lnt"> 92
</span><span class="lnt"> 93
</span><span class="lnt"> 94
</span><span class="lnt"> 95
</span><span class="lnt"> 96
</span><span class="lnt"> 97
</span><span class="lnt"> 98
</span><span class="lnt"> 99
</span><span class="lnt">100
</span><span class="lnt">101
</span><span class="lnt">102
</span><span class="lnt">103
</span><span class="lnt">104
</span><span class="lnt">105
</span><span class="lnt">106
</span><span class="lnt">107
</span><span class="lnt">108
</span><span class="lnt">109
</span><span class="lnt">110
</span><span class="lnt">111
</span><span class="lnt">112
</span><span class="lnt">113
</span><span class="lnt">114
</span><span class="lnt">115
</span><span class="lnt">116
</span><span class="lnt">117
</span><span class="lnt">118
</span><span class="lnt">119
</span><span class="lnt">120
</span><span class="lnt">121
</span><span class="lnt">122
</span><span class="lnt">123
</span><span class="lnt">124
</span><span class="lnt">125
</span><span class="lnt">126
</span><span class="lnt">127
</span><span class="lnt">128
</span><span class="lnt">129
</span><span class="lnt">130
</span><span class="lnt">131
</span><span class="lnt">132
</span><span class="lnt">133
</span><span class="lnt">134
</span><span class="lnt">135
</span><span class="lnt">136
</span><span class="lnt">137
</span><span class="lnt">138
</span><span class="lnt">139
</span><span class="lnt">140
</span><span class="lnt">141
</span><span class="lnt">142
</span><span class="lnt">143
</span><span class="lnt">144
</span><span class="lnt">145
</span><span class="lnt">146
</span><span class="lnt">147
</span><span class="lnt">148
</span><span class="lnt">149
</span><span class="lnt">150
</span><span class="lnt">151
</span><span class="lnt">152
</span><span class="lnt">153
</span><span class="lnt">154
</span><span class="lnt">155
</span><span class="lnt">156
</span><span class="lnt">157
</span><span class="lnt">158
</span><span class="lnt">159
</span><span class="lnt">160
</span><span class="lnt">161
</span><span class="lnt">162
</span><span class="lnt">163
</span><span class="lnt">164
</span><span class="lnt">165
</span><span class="lnt">166
</span><span class="lnt">167
</span><span class="lnt">168
</span><span class="lnt">169
</span><span class="lnt">170
</span><span class="lnt">171
</span><span class="lnt">172
</span><span class="lnt">173
</span><span class="lnt">174
</span><span class="lnt">175
</span><span class="lnt">176
</span><span class="lnt">177
</span><span class="lnt">178
</span><span class="lnt">179
</span><span class="lnt">180
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">#define _GNU_SOURCE
</span></span><span class="line"><span class="cl">#include &lt;stdio.h&gt;
</span></span><span class="line"><span class="cl">#include &lt;string.h&gt;
</span></span><span class="line"><span class="cl">#include &lt;stdlib.h&gt;
</span></span><span class="line"><span class="cl">#include &lt;signal.h&gt;
</span></span><span class="line"><span class="cl">#include &lt;errno.h&gt;
</span></span><span class="line"><span class="cl">#include &lt;syslog.h&gt;
</span></span><span class="line"><span class="cl">#include &lt;fcntl.h&gt;
</span></span><span class="line"><span class="cl">#include &lt;stdarg.h&gt;
</span></span><span class="line"><span class="cl">#include &lt;sys/types.h&gt;          /* See NOTES */
</span></span><span class="line"><span class="cl">#include &lt;sys/socket.h&gt;
</span></span><span class="line"><span class="cl">#include &lt;netinet/in.h&gt;
</span></span><span class="line"><span class="cl">#include &lt;arpa/inet.h&gt;
</span></span><span class="line"><span class="cl">#include &lt;unistd.h&gt;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">#define SIGHUP_NO (1 &lt;&lt; 0)
</span></span><span class="line"><span class="cl">#define SIGQUIT_NO (1 &lt;&lt; 1)
</span></span><span class="line"><span class="cl">#define SIGUSR1_NO (1 &lt;&lt; 2)
</span></span><span class="line"><span class="cl">#define SIGUSR2_NO (1 &lt;&lt; 3)
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">#define non_blocking(fd) fcntl(fd, F_SETFL, fcntl(fd, F_GETFL, 0) | O_NONBLOCK);
</span></span><span class="line"><span class="cl">#define close_on_exec(fd) fcntl(fd, F_SETFD, fcntl(fd, F_GETFD) | FD_CLOEXEC);
</span></span><span class="line"><span class="cl">#define log_write(message) write(logfd, message, strlen(message));
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">char **global_argv;
</span></span><span class="line"><span class="cl">char **global_envp;
</span></span><span class="line"><span class="cl">int flag = 0;
</span></span><span class="line"><span class="cl">int logfd = 0;
</span></span><span class="line"><span class="cl">int serverfd = 0;
</span></span><span class="line"><span class="cl">int maxfd = 0;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">void restart(void);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">void sig_handler(int sig) {
</span></span><span class="line"><span class="cl">    if (sig == SIGHUP) {
</span></span><span class="line"><span class="cl">        flag |= SIGHUP_NO;
</span></span><span class="line"><span class="cl">    } else if (sig == SIGQUIT) {
</span></span><span class="line"><span class="cl">        flag |= SIGQUIT_NO;
</span></span><span class="line"><span class="cl">    } else if (sig == SIGUSR1) {
</span></span><span class="line"><span class="cl">        flag |= SIGUSR1_NO;
</span></span><span class="line"><span class="cl">    } else if (sig == SIGUSR2) {
</span></span><span class="line"><span class="cl">        flag |= SIGUSR2_NO;
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">int create_tcp_server() {
</span></span><span class="line"><span class="cl">    int serverfd = socket(AF_INET, SOCK_STREAM, 0);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    struct sockaddr_in server_addr;
</span></span><span class="line"><span class="cl">    memset(&amp;server_addr, 0, sizeof(server_addr));
</span></span><span class="line"><span class="cl">    server_addr.sin_family = AF_INET;
</span></span><span class="line"><span class="cl">    server_addr.sin_addr.s_addr = inet_addr(&#34;0.0.0.0&#34;);
</span></span><span class="line"><span class="cl">    server_addr.sin_port = htons(8888);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    if (bind(serverfd, (struct sockaddr *)&amp;server_addr, sizeof(struct sockaddr)) == -1) {
</span></span><span class="line"><span class="cl">        exit(-1);
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    listen(serverfd, 128);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    non_blocking(serverfd);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    return serverfd;
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">int main(int argc, char *argv[], char *envp[]) {
</span></span><span class="line"><span class="cl">    global_argv = argv;
</span></span><span class="line"><span class="cl">    global_envp = envp;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    signal(SIGHUP, sig_handler);
</span></span><span class="line"><span class="cl">    signal(SIGQUIT, sig_handler);
</span></span><span class="line"><span class="cl">    signal(SIGUSR1, sig_handler);
</span></span><span class="line"><span class="cl">    signal(SIGUSR2, sig_handler);
</span></span><span class="line"><span class="cl">    signal(SIGPIPE, SIG_IGN);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    // 如果是升级程序，则不需要创建监听文件描述符，直接用父进程继承过来的即可
</span></span><span class="line"><span class="cl">    char *newbinary_env = getenv(&#34;NEWBINARY&#34;);
</span></span><span class="line"><span class="cl">    if (newbinary_env == NULL) {
</span></span><span class="line"><span class="cl">        serverfd = create_tcp_server();
</span></span><span class="line"><span class="cl">    } else {
</span></span><span class="line"><span class="cl">        serverfd = atoi(newbinary_env);
</span></span><span class="line"><span class="cl">        unsetenv(&#34;NEWBINARY&#34;);
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    maxfd = serverfd;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    logfd = open(&#34;./mydaemon.log&#34;, O_RDWR | O_CREAT | O_APPEND, 0666);
</span></span><span class="line"><span class="cl">    close_on_exec(logfd);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    fd_set readfds;
</span></span><span class="line"><span class="cl">    FD_ZERO(&amp;readfds);
</span></span><span class="line"><span class="cl">    FD_SET(serverfd, &amp;readfds);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    while(1) {
</span></span><span class="line"><span class="cl">        struct timeval timeout;
</span></span><span class="line"><span class="cl">        timeout.tv_sec = 1;
</span></span><span class="line"><span class="cl">        timeout.tv_usec = 0;
</span></span><span class="line"><span class="cl">        fd_set ev_readfds = readfds;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        int ready = select(maxfd + 1, &amp;ev_readfds, NULL, NULL, &amp;timeout);
</span></span><span class="line"><span class="cl">        if (ready &gt; 0) {
</span></span><span class="line"><span class="cl">            int fd = 0;
</span></span><span class="line"><span class="cl">            for (; fd &lt;= maxfd; ++fd) {
</span></span><span class="line"><span class="cl">                if (ready == 0) {
</span></span><span class="line"><span class="cl">                    break;
</span></span><span class="line"><span class="cl">                }
</span></span><span class="line"><span class="cl">                if (FD_ISSET(fd, &amp;ev_readfds)) {
</span></span><span class="line"><span class="cl">                    ready --;
</span></span><span class="line"><span class="cl">                    if (fd == serverfd) {
</span></span><span class="line"><span class="cl">                        log_write(&#34;new connection.\n&#34;);
</span></span><span class="line"><span class="cl">                        int connfd = accept(fd, NULL, NULL);
</span></span><span class="line"><span class="cl">                        if (connfd &gt; maxfd) {
</span></span><span class="line"><span class="cl">                            maxfd = connfd;
</span></span><span class="line"><span class="cl">                        }
</span></span><span class="line"><span class="cl">                        FD_SET(connfd, &amp;readfds);
</span></span><span class="line"><span class="cl">                        close_on_exec(connfd);
</span></span><span class="line"><span class="cl">                    } else {
</span></span><span class="line"><span class="cl">                        log_write(&#34;connection echo reply.\n&#34;);
</span></span><span class="line"><span class="cl">                        char buffer[1024] = {0};
</span></span><span class="line"><span class="cl">                        int nbytes = read(fd, buffer, 1024);
</span></span><span class="line"><span class="cl">                        if (nbytes &lt;= 0) {
</span></span><span class="line"><span class="cl">                            close(fd);
</span></span><span class="line"><span class="cl">                            FD_CLR(fd, &amp;readfds);
</span></span><span class="line"><span class="cl">                        } else {
</span></span><span class="line"><span class="cl">                            write(fd, buffer, nbytes);
</span></span><span class="line"><span class="cl">                        }
</span></span><span class="line"><span class="cl">                    }
</span></span><span class="line"><span class="cl">                }
</span></span><span class="line"><span class="cl">            }
</span></span><span class="line"><span class="cl">        } else if (ready == 0) {
</span></span><span class="line"><span class="cl">            log_write(&#34;select timeout.\n&#34;);
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        if (flag &amp; SIGUSR1_NO) {
</span></span><span class="line"><span class="cl">            flag &amp;= ~SIGUSR1_NO;
</span></span><span class="line"><span class="cl">            close(logfd);
</span></span><span class="line"><span class="cl">            logfd = open(&#34;./mydaemon.log&#34;, O_RDWR | O_CREAT | O_APPEND, 0666);
</span></span><span class="line"><span class="cl">            close_on_exec(logfd);
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        if (flag &amp; SIGUSR2_NO) {
</span></span><span class="line"><span class="cl">            flag &amp;= ~SIGUSR2_NO;
</span></span><span class="line"><span class="cl">            restart();
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">    return 0;
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">void restart() {
</span></span><span class="line"><span class="cl">    if (fork() &gt; 0) {
</span></span><span class="line"><span class="cl">        exit(0);
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    // 1. 获取环境变量个数
</span></span><span class="line"><span class="cl">    int envnum = 0;
</span></span><span class="line"><span class="cl">    while (global_envp[envnum] != NULL) {
</span></span><span class="line"><span class="cl">        envnum ++;
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    // 2. 分配存储环境变量指针列表的空间
</span></span><span class="line"><span class="cl">    char **new_envp = malloc(sizeof(char*) * (envnum + 2));
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    int i;
</span></span><span class="line"><span class="cl">    for (i = 0; i &lt; envnum; ++i) {
</span></span><span class="line"><span class="cl">        new_envp[i] = global_envp[i];
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    // 3. 在最后添加一个新的环境变量，NEWBINARY
</span></span><span class="line"><span class="cl">    char newbinary_env[128] = {0};
</span></span><span class="line"><span class="cl">    snprintf(newbinary_env, 128, &#34;NEWBINARY=%d&#34;, serverfd);
</span></span><span class="line"><span class="cl">    new_envp[envnum] = newbinary_env;
</span></span><span class="line"><span class="cl">    new_envp[envnum + 1] = NULL;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    // 4. 执行新的程序
</span></span><span class="line"><span class="cl">    //execvpe(global_argv[0], global_argv, new_envp);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    putenv(newbinary_env);
</span></span><span class="line"><span class="cl">    execvp(global_argv[0], global_argv);
</span></span><span class="line"><span class="cl">    exit(-1);
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>上面代码先用 select IO复用机制，做了一个简单的回声服务器。并在 main 里判断是否设置了 NEWBINARY 环境变量。</p>
<ul>
<li>如果设置了，就走热重启路线</li>
<li>没设置，就走正常启动路线</li>
</ul>
<p>当收到 USR1 信号后，会关闭日志文件，并重新打开，且设置文件的 FD_CLOEXEC 属性，当子进程之心新程序时，日志文件不会被继承。另外注意，每个客户端套接字也同样设置了 FD_CLOEXEC 属性，不让子进程程序继承。</p>
<p>当收到 USR2 信号后，这里处理的比较暴力，直接退出了父进程（正常的情况下，要等子进程资源初始化好后，并开始处理连接了，再通过管道通知父进程优雅关闭）。子进程设置环境变量，告诉程序“监听文件描述符”是多少。等程序启动后，就不需要再重新创建了，而是直接拿来用，但注意要在程序里清除环境变量。</p>
<p>环境的设置方法可以通过 execvpe 传递，也可以使用 putenv 函数传递。环境变量的删除用 unsetenv。</p>
<p>最后，文件一旦被某个进程持有，无论你是移动它，还是删除它，在内核里这种进程引用文件的关系不会改变，文件资源也不会释放（直到所有引用它的进程退出）。所以我们在升级 nginx 这类软件的时候，可以直接替换程序文件，再发送 USR2 信号，实现无缝升级。</p>
<h2 id="平滑重启方法的对比">平滑重启方法的对比</h2>
<p><strong>代码无侵入</strong></p>
<p>其实最简单直接的是通过代理实现服务转移，比如要升级 A 进程，我们可以再启动一个实例，等资源初始完可以处理连接了。再把代理请求转发到新实例。老实例的负载均衡权重设置为 0，等处理完了所有请求，就可以终止老的进程了。这种是代码无侵入性的。</p>
<p><strong>代码有侵入</strong></p>
<p>如果有代码侵入性质，那就是 nginx 这种，自己实现平滑切换。这里还只是切换监听套接字。如果是所有客户端套接字的话，那就要用管道、socket pair 这些通知子进程都有哪些文件描述符以及每个连接的上下文信息（可能要用到共享内存）。甚至还会用到 unix socket 来传递文件描述符。</p>

    </div>

    
<footer class="post-footer">
      
      <nav class="post-nav">
        <a class="prev" href="/post/linux-%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E4%B8%8E-strace/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">Linux 系统调用与 strace</span>
            <span class="prev-text nav-mobile">Prev</span>
          </a>
        <a class="next" href="/post/%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E8%B0%83%E4%BC%98-cpu/">
            <span class="next-text nav-default">性能分析调优 - CPU</span>
            <span class="next-text nav-mobile">Next</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
  <a href="http://blog.gongchang.me/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    Powered by <a class="hexo-link" href="https://gohugo.io">Hugo</a>
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    Theme - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2017 - 
    2022<span class="heart"><i class="iconfont icon-heart"></i></span><span>olOwOlo</span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script><script></script><script src="https://cdn.jsdelivr.net/npm/raphael@2.2.7/raphael.min.js" integrity="sha256-67By+NpOtm9ka1R6xpUefeGOY8kWWHHRAKlvaTJ7ONI=" crossorigin="anonymous"></script> <script src="https://cdn.jsdelivr.net/npm/flowchart.js@1.8.0/release/flowchart.min.js" integrity="sha256-zNGWjubXoY6rb5MnmpBNefO0RgoVYfle9p0tvOQM+6k=" crossorigin="anonymous"></script><script></script><script src="https://cdn.jsdelivr.net/npm/webfontloader@1.6.28/webfontloader.js" integrity="sha256-4O4pS1SH31ZqrSO2A/2QJTVjTPqVe+jnYgOWUVr7EEc=" crossorigin="anonymous"></script> <script src="https://cdn.jsdelivr.net/npm/snapsvg@0.5.1/dist/snap.svg-min.js" integrity="sha256-oI+elz+sIm+jpn8F/qEspKoKveTc5uKeFHNNVexe6d8=" crossorigin="anonymous"></script> <script src="https://cdn.jsdelivr.net/npm/underscore@1.8.3/underscore-min.js" integrity="sha256-obZACiHd7gkOk9iIL/pimWMTJ4W/pBsKu+oZnSeBIek=" crossorigin="anonymous"></script> <script src="https://cdn.jsdelivr.net/gh/bramp/js-sequence-diagrams@2.0.1/dist/sequence-diagram-min.js" integrity="sha384-8748Vn52gHJYJI0XEuPB2QlPVNUkJlJn9tHqKec6J3q2r9l8fvRxrgn/E5ZHV0sP" crossorigin="anonymous"></script>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/bramp/js-sequence-diagrams@2.0.1/dist/sequence-diagram-min.css" integrity="sha384-6QbLKJMz5dS3adWSeINZe74uSydBGFbnzaAYmp+tKyq60S7H2p6V7g1TysM5lAaF" crossorigin="anonymous">



<script type="text/javascript" src="/js/main.min.4ae89da218555efa0e7093a20b92017d2e1202b66fff9fc2edf4cb8d44b44c6e.js"></script>








</body>
</html>
