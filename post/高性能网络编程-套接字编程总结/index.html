<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>高性能网络编程 - 套接字编程总结 - 弓长笔记</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="jincheng9" /><meta name="description" content="创建 socket 1 2 3 4 #include &amp;lt;sys/types.h&amp;gt; /* See NOTES */ #include &amp;lt;sys/socket.h&amp;gt; int socket(int domain, int type, int protocol); 创建不同类型的套接字（ipv4 还是 ipv6 取决于 domain 参数，tcp 还是 udp 取决于 type 参数） 创建 tcp4 1 int ipv4_tcp_fd = socket(AF_INET, SOCK_STREAM, 0);" /><meta name="keywords" content="Hugo, theme, even" />






<meta name="generator" content="Hugo 0.101.0 with theme even" />


<link rel="canonical" href="http://blog.gongchang.me/post/%E9%AB%98%E6%80%A7%E8%83%BD%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-%E5%A5%97%E6%8E%A5%E5%AD%97%E7%BC%96%E7%A8%8B%E6%80%BB%E7%BB%93/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.b5a744db6de49a86cadafb3b70f555ab443f83c307a483402259e94726b045ff.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:title" content="高性能网络编程 - 套接字编程总结" />
<meta property="og:description" content="创建 socket 1 2 3 4 #include &lt;sys/types.h&gt; /* See NOTES */ #include &lt;sys/socket.h&gt; int socket(int domain, int type, int protocol); 创建不同类型的套接字（ipv4 还是 ipv6 取决于 domain 参数，tcp 还是 udp 取决于 type 参数） 创建 tcp4 1 int ipv4_tcp_fd = socket(AF_INET, SOCK_STREAM, 0);" />
<meta property="og:type" content="article" />
<meta property="og:url" content="http://blog.gongchang.me/post/%E9%AB%98%E6%80%A7%E8%83%BD%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-%E5%A5%97%E6%8E%A5%E5%AD%97%E7%BC%96%E7%A8%8B%E6%80%BB%E7%BB%93/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2022-04-15T23:09:31+08:00" />
<meta property="article:modified_time" content="2022-04-15T23:09:31+08:00" />

<meta itemprop="name" content="高性能网络编程 - 套接字编程总结">
<meta itemprop="description" content="创建 socket 1 2 3 4 #include &lt;sys/types.h&gt; /* See NOTES */ #include &lt;sys/socket.h&gt; int socket(int domain, int type, int protocol); 创建不同类型的套接字（ipv4 还是 ipv6 取决于 domain 参数，tcp 还是 udp 取决于 type 参数） 创建 tcp4 1 int ipv4_tcp_fd = socket(AF_INET, SOCK_STREAM, 0);"><meta itemprop="datePublished" content="2022-04-15T23:09:31+08:00" />
<meta itemprop="dateModified" content="2022-04-15T23:09:31+08:00" />
<meta itemprop="wordCount" content="9191">
<meta itemprop="keywords" content="" /><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="高性能网络编程 - 套接字编程总结"/>
<meta name="twitter:description" content="创建 socket 1 2 3 4 #include &lt;sys/types.h&gt; /* See NOTES */ #include &lt;sys/socket.h&gt; int socket(int domain, int type, int protocol); 创建不同类型的套接字（ipv4 还是 ipv6 取决于 domain 参数，tcp 还是 udp 取决于 type 参数） 创建 tcp4 1 int ipv4_tcp_fd = socket(AF_INET, SOCK_STREAM, 0);"/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">弓长笔记</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">主页</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">全部文章</li>
      </a><a href="/about/">
        <li class="mobile-menu-item">关于</li>
      </a>
  </ul>

  


</nav>

  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">弓长笔记</a>
</div>





<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">主页</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">全部文章</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/about/">关于</a>
      </li>
  </ul>
</nav>

    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">高性能网络编程 - 套接字编程总结</h1>

      <div class="post-meta">
        <span class="post-time"> 2022-04-15 </span>
        
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">Contents</h2>
  <div class="post-toc-content always-active">
    <nav id="TableOfContents">
  <ul>
    <li><a href="#创建-socket">创建 socket</a>
      <ul>
        <li><a href="#心跳保活机制">心跳保活机制</a></li>
        <li><a href="#延迟发送">延迟发送</a></li>
        <li><a href="#延迟确认">延迟确认</a></li>
        <li><a href="#发送和接收超时">发送和接收超时</a></li>
        <li><a href="#发送和接收缓冲区大小">发送和接收缓冲区大小</a></li>
        <li><a href="#发送和接收缓冲区低水位">发送和接收缓冲区低水位</a></li>
        <li><a href="#地址重用--端口重用">地址重用 &amp; 端口重用</a></li>
      </ul>
    </li>
    <li><a href="#绑定-socket">绑定 socket</a></li>
    <li><a href="#主动连接-connect">主动连接 connect</a></li>
    <li><a href="#监听-socket">监听 socket</a>
      <ul>
        <li><a href="#什么是半连接队列">什么是半连接队列</a></li>
        <li><a href="#什么是全连接队列">什么是全连接队列</a></li>
      </ul>
    </li>
    <li><a href="#获取连接-accept">获取连接 accept</a></li>
    <li><a href="#读写数据的-flag-标志位">读写数据的 flag 标志位</a></li>
    <li><a href="#tcp-字节流收发">TCP 字节流收发</a>
      <ul>
        <li><a href="#什么是-mss">什么是 MSS？</a></li>
        <li><a href="#发送数据的各种问题">发送数据的各种问题</a></li>
        <li><a href="#发送方法的原子性和线程安全">发送方法的原子性和线程安全</a></li>
        <li><a href="#接收数据的各种问题">接收数据的各种问题</a></li>
      </ul>
    </li>
    <li><a href="#关闭-socket">关闭 socket</a>
      <ul>
        <li><a href="#close-监听套接字">close 监听套接字</a></li>
        <li><a href="#close-连接套接字">close 连接套接字</a></li>
        <li><a href="#so_linger-这个选项的用处在哪">SO_LINGER 这个选项的用处在哪？</a></li>
        <li><a href="#close-和-shutdown-的区别">close 和 shutdown 的区别</a></li>
      </ul>
    </li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <h1 id="创建-socket">创建 socket</h1>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">#include &lt;sys/types.h&gt;          /* See NOTES */
</span></span><span class="line"><span class="cl">#include &lt;sys/socket.h&gt;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">int socket(int domain, int type, int protocol);
</span></span></code></pre></td></tr></table>
</div>
</div><p>创建不同类型的套接字（ipv4 还是 ipv6 取决于 domain 参数，tcp 还是 udp 取决于 type 参数）</p>
<p>创建 tcp4</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">int ipv4_tcp_fd = socket(AF_INET, SOCK_STREAM, 0);
</span></span></code></pre></td></tr></table>
</div>
</div><p>创建udp4</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">int ipv4_udp_fd = socket(AF_INET, SOCK_DGRAM, 0);
</span></span></code></pre></td></tr></table>
</div>
</div><p>创建tcp6</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">int ipv6_tcp_fd = socket(AF_INET6, SOCK_STREAM, 0);
</span></span></code></pre></td></tr></table>
</div>
</div><p>创建udp6</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">int ipv6_udp_fd = socket(AF_INET6, SOCK_DGRAM, 0);
</span></span></code></pre></td></tr></table>
</div>
</div><p>原始套接字</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">// 原始套接字工作在 ICMP 这一层，发送 ICMP 报文，收到的是 ICMP over IP 报文
</span></span><span class="line"><span class="cl">int raw_sock_fd = socket(AF_PACKET, SOCK_RAW, IPPROTO_ICMP);
</span></span></code></pre></td></tr></table>
</div>
</div><p>创建本地字节流套接字</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">int localunix_fd = socket(AF_LOCAL, SOCK_STREAM, 0);
</span></span></code></pre></td></tr></table>
</div>
</div><p>通常我们创建完 socket 后，会用 setsockopt 来设置以下几种选项：</p>
<ul>
<li>心跳保活机制，SO_KEEPALIVE</li>
<li>延迟发送，TCP_NODELAY &amp; TCP_CORK</li>
<li>延迟关闭，SO_LINGER</li>
<li>发送和接收超时，SO_SNDTIMEO &amp; SO_RCVTIMEO</li>
<li>发送和接收缓冲区大小，SO_SNDBUF &amp; SO_RCVBUF</li>
<li>发送和接收缓冲区低水位，SO_SNDLOWAT &amp; SO_RCVLOWAT</li>
<li>地址端口重用，SO_REUSEADDR &amp; SO_REUSEPORT</li>
</ul>
<h2 id="心跳保活机制">心跳保活机制</h2>
<p>当一个TCP连接，长时间（一般是 2 小时）没有数据交互，操作系统底层会自动回收该连接，给对端发送 RST 重置报文。</p>
<p>我们可以通过命令获取每个套接字的默认 keepalive</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">$ sysctl -a | grep -i keepalive
</span></span><span class="line"><span class="cl">net.ipv4.tcp_keepalive_intvl = 75
</span></span><span class="line"><span class="cl">net.ipv4.tcp_keepalive_probes = 9
</span></span><span class="line"><span class="cl">net.ipv4.tcp_keepalive_time = 7200
</span></span><span class="line"><span class="cl">...
</span></span></code></pre></td></tr></table>
</div>
</div><p>大意就是，7200 秒后还没有数据交互，就发送探测报文，连续发送 9 次，每次发送间隔 75 秒，如果最终还没收到回复，就发 RST 报文到 peer 重置连接，本连接释放。</p>
<h2 id="延迟发送">延迟发送</h2>
<ul>
<li>
<p>Nagle 算法的目的：避免发送大量的小包，网络上每次只能一个小包存在，在小包被确认之前，只能积累大包。是一种牺牲小我，成全大家（互联网）的手段。以下条件都是成立在无未确认的网络包时。</p>
<ul>
<li>如果包长度达到 MSS，则立即发送；</li>
<li>如果该包含有 FIN、RST，则立即发送；</li>
<li>设置 TCP_NODELAY 选项，就意味着禁用 Nagle 算法，数据包基本是立即发送出去的；</li>
<li>上述条件都未满足，发生了超时（一般为 200 ms），也立即发送。</li>
</ul>
</li>
<li>
<p>Cork 算法的目的：更激进的 Nagle，完全避免小包的发送，只发送 MSS 大小的包及不得不发的小包。也就说，一个包大小不足 MSS，就永远不会发送。</p>
</li>
</ul>
<p>当应用类型需要小包的实时交互，那就最好关闭 Nagle 和 Cork 两个选项。</p>
<blockquote>
<p>其中在 Linux 内核中，Nagle 默认开启，Cork 默认关闭。</p>
</blockquote>
<p><img src="/img/tcp_nagle.png" alt=""></p>
<h2 id="延迟确认">延迟确认</h2>
<p>当服务器开启了 TCP Delayed Ack，客户端又开启了 Nagle‘s Algorithm，会导致什么问题呢？</p>
<p>想象一种场景，客户端发送的数据包比较小，然后发送端在等待服务端对上一个包的 Ack，只有收到 Ack 后继续发送下一个包，而服务器却延迟了此 Ack 的发送，那么客户端的发送过程同样被延迟。一般就是 40ms。</p>
<p>小包交互场景，最好关闭延迟发送和延迟确认。</p>
<p><img src="/img/tcp_delay_ack.png" alt=""></p>
<h2 id="发送和接收超时">发送和接收超时</h2>
<p>当文件描述符是阻塞时，读写 IO 可能会造成阻塞睡眠。那么 SO_RCVTIMEO 和 SO_SNDTIMEO，就是用来设置 socket 接收数据超时时间和发送数据超时时间的。</p>
<p>这两个选项仅对与数据收发相关的系统调用有效。</p>
<ul>
<li>接收超时会影响 read、readv、recv、recvfrom</li>
<li>发送超时会影响 write、writev、send、sendto</li>
</ul>
<h2 id="发送和接收缓冲区大小">发送和接收缓冲区大小</h2>
<p>每个 TCP 套接字都有一个发送缓存区和一个接收缓存区，每个 UDP 套接字都有一个接收缓存区。</p>
<ul>
<li>SO_SNDBUF：发送缓冲区的容量上限</li>
<li>SO_RCVBUF：接受缓冲区的容量上限</li>
</ul>
<p>对于 TCP 连接而言，传输吞吐效率依赖于发送方和接收方两方的窗口大小。因此只调大发送方缓存并不会对整体效率产生明显影响。</p>
<p>延时大的网络上的带宽利用率低，主要原因是延时变大之后，发送方发的数据不能及时到达接收方。导致发送窗口满之后，不能再持续发送数据。接收方的接收缓存小的话，则会通告对方发送窗口变小。进而影响发送方不能以大窗口发送数据。所以，调优思路应该是，发送方调大 tcp_wmem，接收方调大 tcp_rmem。</p>
<h2 id="发送和接收缓冲区低水位">发送和接收缓冲区低水位</h2>
<p>每个 TCP 套接字都有一个“接收低水位”和一个“发送低水位”</p>
<ul>
<li>接收低水位，对于 TCP 而言，接收缓冲区中的数据必须 &gt;= 低水位值，内核才通知进程“可读”。比如触发 select 或 epoll 的“读事件”。</li>
<li>发送低水位，对于 TCP 而言，发送缓冲区剩余容量必须 &gt;= 低水位值，内核才通知进程“可写”。</li>
</ul>
<p>Linux 系统中，低水位的值默认都是 1 字节，意味着：</p>
<ul>
<li>socket 接收缓冲区只要有数据，就能读</li>
<li>socket 发送缓冲区只要有 1 个字节空间，就能写</li>
</ul>
<p>另外再解释下读的低水位，比如设置的是 64，然后内核缓冲区里只收到 63 个字节，那么 read 调用将会阻塞，直到缓冲区里有 64 个字节以上的内容才会返回。</p>
<h2 id="地址重用--端口重用">地址重用 &amp; 端口重用</h2>
<p>通常一个连接释放后会等待两分钟（2MSL）之后才能再被使用，SO_REUSEADDR 是让端口释放后立即就可以被再次使用。设置 SO_REUSEADDR 可重用处于 TIME_WAIT 状态的连接。</p>
<p>SO_REUSEPORT 主要解决了两个问题：</p>
<ol>
<li>单个 listen socket 遇到的性能瓶颈。</li>
<li>单个 listen socket 多个线程同时 accept，但是多个线程资源分配不均。</li>
</ol>
<p>当开启 SO_REUSEPORT 后，有多个 listener 共同 bind/listen 相同的 IP/PORT，也就是说每个进程/线程有一个独立的 listener，相当于每个进程/线程独享一个 listener 的全连接队列，不需要多个进程/线程竞争某个公共资源，能充分利用多核，减少竞争的资源消耗，效率自然提高了。</p>
<p>Nginx 解决多线程竞争连接的方案是加锁，某个线程获取到锁，就由这个线程处理 listen socket。</p>
<p>不过 Nginx 在 2015 年，1.9.1 版本也增加对应功能的支持，nginx 开启 reuseport 功能后，性能是原来的 2-3 倍，效果可谓立竿见影！</p>
<h1 id="绑定-socket">绑定 socket</h1>
<p>用赋值方式初始化 ipv4 套接字</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">struct sockaddr_in mysock;
</span></span><span class="line"><span class="cl">bzero(&amp;mysock, sizeof(mysock));
</span></span><span class="line"><span class="cl">mysock.sin_family = AF_INET;
</span></span><span class="line"><span class="cl">mysock.sin_port = htons(800);
</span></span><span class="line"><span class="cl">mysock.sin_addr.s_addr = inet_addr(&#34;192.168.1.100&#34;);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">bind(sock_fd, (struct sockaddr*)&amp;mysock, sizeof(struct sockaddr));
</span></span></code></pre></td></tr></table>
</div>
</div><p>用 inet_pton 初始化 ipv6 套接字</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">struct ifreq req;
</span></span><span class="line"><span class="cl">strcpy(req.ifr_name, &#34;eth0&#34;);
</span></span><span class="line"><span class="cl">if (ioctl(sd, SIOCGIFINDEX, &amp;req) &lt; 0) {
</span></span><span class="line"><span class="cl">    perror(&#34;gifindex&#34;);
</span></span><span class="line"><span class="cl">    return 1;
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">struct sockaddr_in6  to;
</span></span><span class="line"><span class="cl">to.sin6_family = AF_INET6;
</span></span><span class="line"><span class="cl">to.sin6_port = htons(10086);
</span></span><span class="line"><span class="cl">to.sin6_scope_id = req.ifr_ifindex;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">if (inet_pton(AF_INET6, &#34;fe80::20c:29ff:fe34:a9b4&#34;, &amp;to.sin6_addr) &lt;= 0) {
</span></span><span class="line"><span class="cl">    perror(&#34;pton&#34;);
</span></span><span class="line"><span class="cl">    return 1;
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">bind(sock_fd, (struct sockaddr*)&amp;mysock, sizeof(struct sockaddr));
</span></span></code></pre></td></tr></table>
</div>
</div><p>用 strcpy 初始化 UNIX 域套接字</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">const char *local_path = &#34;/tmp/mysock.sock&#34;;
</span></span><span class="line"><span class="cl">unlink(local_path);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">struct sockaddr_un servaddr;
</span></span><span class="line"><span class="cl">bzero(&amp;servaddr, sizeof(servaddr));
</span></span><span class="line"><span class="cl">servaddr.sun_family = AF_LOCAL;
</span></span><span class="line"><span class="cl">strcpy(servaddr.sun_path, local_path);
</span></span></code></pre></td></tr></table>
</div>
</div><p><strong>UDP &amp; TCP 可以共用一个地址和端口吗？</strong></p>
<p>可以，因为一个连接是用五元组表示（protocol、src ip、src port、dst ip、dst port）</p>
<p>所以 UDP、TCP 客户端套接字都可以显式绑定一个地址和端口。</p>
<p>通常，我们的程序同时提供 UDP &amp; TCP 服务时，都会绑定 socket 到一个指定的端口上面。</p>
<p><strong>未 bind() 时的默认地址端口是什么？</strong></p>
<p>默认地址是 0.0.0.0，对应一个外网的接口。</p>
<p>默认端口从 ip_local_port_range 参数中随机选择一个为占用的。可以看到，客户端的随机端口范围是 32768-60999</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">$ cat /proc/sys/net/ipv4/ip_local_port_range
</span></span><span class="line"><span class="cl">32768   60999
</span></span></code></pre></td></tr></table>
</div>
</div><p>通过 sysctl 命令可以修改这个范围，sysctl 的配置文件 /etc/sysctl.conf。也可以通过 sysctl -a 命令查看这些参数的配置信息。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">$ sysctl -a | grep -i ip_local_port_range
</span></span><span class="line"><span class="cl">net.ipv4.ip_local_port_range = 32768    60999
</span></span></code></pre></td></tr></table>
</div>
</div><p>当修改了 /etc/sysctl.conf 文件后，可以执行命令使之生效 sysctl -p /etc/sysctl.conf</p>
<h1 id="主动连接-connect">主动连接 connect</h1>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">#include &lt;sys/types.h&gt;          /* See NOTES */
</span></span><span class="line"><span class="cl">#include &lt;sys/socket.h&gt;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">int connect(int sockfd, const struct sockaddr *addr, socklen_t addrlen);
</span></span></code></pre></td></tr></table>
</div>
</div><p>返回成功，就代表与服务器完成了三次握手。</p>
<p><strong>能发起多少 TCP 连接呢？</strong></p>
<p>限制的要素：</p>
<ol>
<li>这个取决于进程能打开的文件描述符数量；</li>
<li>一个连接是用五元组 {来源IP，来源端口，目的IP，目的端口，协议} 表示，由于协议和目的IP、端口都是固定的，所以我们只能通过改变来源IP和来源端口来增加连接数量。</li>
</ol>
<p>增加连接数的方法：</p>
<ol>
<li>通过 ip_local_port_range 参数控制端口范围；</li>
<li>来源 IP 可以通过多物理网卡来实现，如果没有多个物理网卡就不能突破连接外网服务的限制。如果是突破内网的连接数量很简单，虚拟出多个网卡就行了。</li>
</ol>
<p><strong>UDP 的 connect 行为</strong></p>
<p>在对 UDP 进行 connect 之后，关于收发函数的使用：</p>
<ul>
<li>使用 send 或 write 函数来发送，如果使用 sendto 需要把相关的 to 地址信息置零（一般设置了也会忽略）</li>
<li>使用 recv 或 read 函数来接收，如果使用 recvfrom 需要把对应的 from 地址信息置零（一般设置了也会忽略）</li>
<li>另一个作用是让 UDP 只和指定的对端通信，忽略其它客户端发来的数据</li>
</ul>
<p><strong>连接不存在的主机会怎样？</strong></p>
<p>一般返回 -1 时可能的 errno 有两种：</p>
<ul>
<li>errno（101 Network is unreachable），收到了对方返回的 ICMP（Type = 3） 报文；</li>
<li>errno（110 Connection timed out），发出去的 SYN 包丢失，服务器返回的 SYN+ACK 包丢失；</li>
</ul>
<p>当包丢失时，或者说发出去的 SYN 得不到响应时，会重试。重试次数使用下面的参数控制。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">$ cat /proc/sys/net/ipv4/tcp_syn_retries
</span></span><span class="line"><span class="cl">6
</span></span></code></pre></td></tr></table>
</div>
</div><p><strong>连接不存在的端口会怎样？</strong></p>
<p>会收到对方的 RST 重置报文，然后 connect 立即返回错误，错误代码 111（Connection refused）</p>
<h1 id="监听-socket">监听 socket</h1>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">#include &lt;sys/types.h&gt;          /* See NOTES */
</span></span><span class="line"><span class="cl">#include &lt;sys/socket.h&gt;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">int listen(int sockfd, int backlog);
</span></span></code></pre></td></tr></table>
</div>
</div><p>成功返回 0，失败返回 -1</p>
<p>在 TCP 三次握手的时候，Linux 内核会维护两个队列，分别是：</p>
<ul>
<li>半连接队列，也称 SYN 队列</li>
<li>全连接队列，也称 accept 队列</li>
</ul>
<p>服务端收到客户端发起的 SYN 请求后，内核会把该连接存储到半连接队列，并向客户端响应 SYN+ACK，接着客户端会返回 ACK，服务端收到第三次握手的 ACK 后，内核会把连接从半连接队列移除，然后创建新的完全的连接，并将其添加到 accept 队列，等待进程调用 accept 把连接取出来。</p>
<h2 id="什么是半连接队列">什么是半连接队列</h2>
<p>目前没有很好的观测半连接队列长度的办法。但是调整参数 backlog 的值，可以扩大半连接队列长度。</p>
<p><strong>半连接队列溢出会发生什么？</strong></p>
<p>取决于 /proc/sys/net/ipv4/tcp_syncookies 参数值（默认是 1），以下是值的说明：</p>
<ul>
<li>0 表示关闭 syn cookies，那么半连接队列满了，就只能丢弃 SYN 包</li>
<li>1 表示当 SYN 半连接队列满了之后，再启用 syn cookies机制</li>
<li>2 在三次握手中，无条件开启 syn cookies 机制</li>
</ul>
<p>当连接是通过 syn cookies 机制交互，那么三次握手完成后，会直接进入全连接队列。</p>
<p><strong>客户端的 ACK 丢了怎么办？</strong></p>
<p>当服务器收到 SYN 包并返回 SYN+ACK 确认包，此时连接是 SYN_RECV 状态，然后进入半连接队列。</p>
<p>那么当服务器再次收到客户端的 ACK 后，就完成了三次握手，此时服务器的连接状态是 ESTABLISHED，然后进入全连接队列，并等待应用程序调用 accpet 获取。</p>
<p>但这里有个问题，如果客户端的 ACK 在半路丢了，怎么办？（要知道，客户端收到服务器的 SYN+ACK 包后，就认为连接建立成功了，不会重发 ACK 确认报文的）</p>
<p>答案是取决于服务器的 /proc/sys/net/ipv4/tcp_synack_retries 的参数，在一般 Linux 系统下默认是 5，也就说服务器会重发 SYN+ACK 包。</p>
<ul>
<li>1 秒后，重发 SYN+ACK</li>
<li>2 秒后，重发 SYN+ACK</li>
<li>4 秒后，重发 SYN+ACK</li>
<li>8 秒后，重发 SYN+ACK</li>
<li>16 秒后，重发 SYN+ACK</li>
<li>又过了 32 秒的时候，还没收到客户端的 ACK 确认包，就丢弃这个连接。所以丢弃一个没收到 ACK （没完整完成三次握手）的连接，总耗时是 (1+2+4+8+16+31) = 63 秒</li>
</ul>
<p><strong>如何避免 SYN Flood 攻击</strong></p>
<p>一般是三种思路：</p>
<ol>
<li>增大半连接队列</li>
<li>开启 tcp_syncookies 功能</li>
<li>减少 SYN+ACK 重传次数（减小 tcp_synack_retries 的值）</li>
</ol>
<h2 id="什么是全连接队列">什么是全连接队列</h2>
<p><strong>如何查看全连接队列大小？</strong></p>
<p>在「LISTEN 状态」时，利用 ss -lnt 命令，Recv-Q/Send-Q 表示的含义如下：</p>
<ul>
<li>Recv-Q：当前全连接队列的大小，也就是当前已完成三次握手并等待服务端 accept() 的 TCP 连接</li>
<li>Send-Q：当前全连接最大队列长度，上面的输出结果说明监听 1234 端口的 TCP 服务，最大全连接长度为 5</li>
</ul>
<p>命令选项说明</p>
<ul>
<li>-l &ndash;listening 显示监听状态的套接字（sockets）</li>
<li>-n &ndash;numeric 不解析服务名称</li>
<li>-t &ndash;tcp 仅显示 TCP套接字（sockets）</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">$ ss -lnt
</span></span><span class="line"><span class="cl">State       Recv-Q Send-Q                                   Local Address:Port                                                  Peer Address:Port
</span></span><span class="line"><span class="cl">LISTEN      0      5                                                    *:1234                                                             *:*
</span></span><span class="line"><span class="cl">LISTEN      0      128                                                  *:22                                                               *:*
</span></span><span class="line"><span class="cl">LISTEN      0      100                                          127.0.0.1:25                                                               *:*
</span></span><span class="line"><span class="cl">LISTEN      0      80                                                [::]:3306                                                          [::]:*
</span></span><span class="line"><span class="cl">LISTEN      0      128                                               [::]:22                                                            [::]:*
</span></span><span class="line"><span class="cl">LISTEN      0      100                                              [::1]:25                                                            [::]:*
</span></span></code></pre></td></tr></table>
</div>
</div><p>而在「非 LISTEN 状态」时，利用 ss -nt 命令Recv-Q/Send-Q 表示的含义如下：</p>
<ul>
<li>Recv-Q：已收到但未被应用进程读取的字节数</li>
<li>Send-Q：已发送但未收到确认的字节数</li>
</ul>
<p><strong>全连接队列溢出会发生什么？</strong></p>
<p>取决于 /proc/sys/net/ipv4/tcp_abort_on_overflow 的值（Linux 默认是 0），含义如下：</p>
<ul>
<li>如果是 0，那么 server 扔掉 client 发过来的 Ack，连接还驻留（半连接队列）里；</li>
<li>如果是 1，server 发送一个 RST 包给 client，表示废掉这个握手过程和这个连接。</li>
</ul>
<p>当超过了 TCP 最大全连接队列，服务端则会丢掉后续进来的 TCP 连接，丢掉的 TCP 连接的个数会被统计起来，我们在服务端可以使用 netstat -s 命令来查看：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">$ netstat -s | grep overflow
</span></span><span class="line"><span class="cl">    388 times the listen queue of a socket overflowed
</span></span></code></pre></td></tr></table>
</div>
</div><p><strong>如何增大全连接队列呢？</strong></p>
<p>全连接队列的长度是：min(backlog, /proc/sys/net/core/somaxconn)</p>
<ol>
<li>修改参数 backlog</li>
<li>调整 /proc/sys/net/core/somaxconn 参数</li>
</ol>
<h1 id="获取连接-accept">获取连接 accept</h1>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">#include &lt;sys/types.h&gt;
</span></span><span class="line"><span class="cl">#include &lt;sys/socket.h&gt;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">#define _GNU_SOURCE          
</span></span><span class="line"><span class="cl">#include &lt;sys/socket.h&gt;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">int accept4(int sockfd, struct sockaddr *addr, socklen_t *addrlen, int flags);
</span></span></code></pre></td></tr></table>
</div>
</div><p>如果在阻塞下，accept 将一直等待，直到一个 TCP 连接到来，返回套接字描述符。</p>
<p>如果是非阻塞下，accept 将返回 -1，errno 等于 11（也就是 EAGIN、EWOULDBLOCK）</p>
<p><strong>accept &amp; accept4 区别？</strong></p>
<p>accept4 函数共有 4 个参数，相比 accept 多了一个 flags 的参数。</p>
<ul>
<li>用户可以通过此参数直接设置套接字的一些属性，如 SOCK_NONBLOCK 或者是 SOCK_CLOEXEC</li>
<li>而当 accept4 的 flags 为 0 时，和 accept 没有区别</li>
</ul>
<p>接下来我们讨论一些异常情况</p>
<p><strong>收到 FIN 后的 accept &amp; read</strong></p>
<ul>
<li>accept 返回值大于 0，得到一个套接字描述符；</li>
<li>调用 read 返回 0，errno 等于 0，代表对方无内容发送（发送了 FIN 包）。</li>
</ul>
<p><strong>收到 RST 后的 accept &amp; read</strong></p>
<ul>
<li>accept 返回值大于 0，得到一个套接字描述符；</li>
<li>调用 read 返回 -1，errno 等于 104（ECONNRESET），代表对方发送了 RST 包。</li>
</ul>
<p><strong>收到 FIN 后的 accept &amp; write</strong></p>
<ul>
<li>accept 返回值大于 0，得到一个套接字描述符；</li>
<li>调用 write 返回写入成功的字节数，此时对端 TCP 状态处于 FIN_WALT，收到我们的数据包后会返回 RST 重置报文。</li>
</ul>
<p><strong>收到 RST 后的 accept &amp; write</strong></p>
<ul>
<li>accept 返回值大于 0，得到一个套接字描述符；</li>
<li>调用 write 返回 -1，errno 等于 104（ECONNRESET），代表对方发送了 RST 重置报文。</li>
</ul>
<h1 id="读写数据的-flag-标志位">读写数据的 flag 标志位</h1>
<p><strong>MSG_PEEK 的作用</strong></p>
<ul>
<li>仅仅是把 tcp 缓冲区中的数据读取到 buf 中，但没有把已读取的数据从 tcp 缓冲区中删除，如果再次调用 recv() 函数仍然可以读到刚才读到的数据。</li>
</ul>
<p><strong>MSG_DONTWAIT 的作用</strong></p>
<ul>
<li>临时将 sockfd 设置为非阻塞模式，而无论原有是阻塞还是非阻塞；</li>
<li>recv(sockfd, buff, buff_size, MSG_DONTWAIT); 临时的非阻塞模式的消息发送；</li>
<li>send(scokfd, buff, buff_size, MSG_DONTWAIT); 临时的非阻塞模式的消息接受；</li>
</ul>
<p><strong>MSG_OOB 的作用</strong></p>
<ul>
<li>一般没人用</li>
<li>[MSG_OOB 带外数据] <a href="https://zhuanlan.zhihu.com/p/380463391">https://zhuanlan.zhihu.com/p/380463391</a></li>
</ul>
<p><strong>MSG_WAITALL 的作用</strong></p>
<ul>
<li>通常我们要获取 1000 个字节，但此时 tcp 缓冲区才 500 个字节，然后 recv 函数就返回了。如果我们强制要求读取完整的 1000 个字节才返回，就要带上 MSG_WAITALL 标志。</li>
</ul>
<h1 id="tcp-字节流收发">TCP 字节流收发</h1>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">#include &lt;sys/types.h&gt;
</span></span><span class="line"><span class="cl">#include &lt;sys/socket.h&gt;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">ssize_t recv(int sockfd, void *buf, size_t len, int flags);
</span></span><span class="line"><span class="cl">ssize_t send(int sockfd, const void *buf, size_t len, int flags);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">#include &lt;unistd.h&gt;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">ssize_t read(int fd, void *buf, size_t count);
</span></span><span class="line"><span class="cl">ssize_t write(int fd, const void *buf, size_t count);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">#include &lt;sys/uio.h&gt;
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl">ssize_t readv(int fd, const struct iovec *iov, int iovcnt);
</span></span><span class="line"><span class="cl">ssize_t writev(int fd, const struct iovec *iov, int iovcnt);
</span></span></code></pre></td></tr></table>
</div>
</div><p>函数调用成功，返回实际读取、写入的字节数。返回 0 代表对端关闭了连接。返回 -1 代表连接出错（收到对方的 RST 报文等）</p>
<h2 id="什么是-mss">什么是 MSS？</h2>
<p>这个问题可以转化为当发送超过 MTU 的大数据，是 IP 分片还是 TCP 分片？</p>
<p>答案是 TCP 进行分片，分片的大小是 MSS（Max Segment Size）。MSS 是 TCP 提出的概念（在三次握手时确定），为什么要有 MSS 呢？</p>
<p>因为无论何种类型的数据链路层，都会对网络分组的长度有一个限制。</p>
<ul>
<li>例如以太网限制为 1500 字节</li>
<li>WIFI 802.3 限制为1492字节。</li>
</ul>
<p>当内核的 IP 层试图发送报文时，若报文的长度大于 MTU 限制，就会被分成若干个小于等于 MTU 的报文，每个报文都会有独立的 IP 头部。</p>
<p>IP 包总长度是用一个 16位（2字节） 的字段表示，这意味一个 IP 包最大是 65535 字节。若 TCP 层在以太网中试图发送一个大于 1500 字节的消息，调用 IP 网络层方法发送消息时，IP 层会自动的获取所在局域网的 MTU，并按照所在网络的 MTU 大小来分片。IP 层同时希望这个分片对于传输层来说是透明的，接收方的 IP 层会根据收到的多个 IP 包头部，将发送方 IP 层分片出的 IP 包重组为一个消息，递交给传输层。</p>
<p>但这种 IP 层的分片效率是很差的，因为必须所有分片都到达才能重组成一个包，其中任何一个分片丢失了，就必须重发所有分片（因为 IP 包不完整了）。所以，TCP 层试图避免 IP 层执行数据报分片，定义了一个新的概念：最大报文段长度 MSS。它定义了一个 TCP 连接上，一个主机期望对端主机发送单个报文的最大长度。TCP 3 次握手建立连接时，连接双方都要互相告知自己期望接收到的 MSS 大小。</p>
<p>例如用 tcpdump 命令抓包可以看到 MSS</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">$ tcpdump -i any -nn -S
</span></span><span class="line"><span class="cl">15:05:08.230782 IP 10.7.80.57.64569 &gt; 10.7.80.58.1234 : S 3027092051:3027092051(0) win 8192 &lt;mss 1460,nop,wscale 8,nop,nop,sackOK&gt;
</span></span><span class="line"><span class="cl">15:05:08.234267 IP 10.7.80.58.1234 &gt; 10.7.80.57.64569: S 26006838:26006838(0) ack 3027092052 win 5840 &lt;mss 1460,nop,nop,sackOK,nop,wscale 9&gt;
</span></span><span class="line"><span class="cl">15:05:08.233320 IP 10.7.80.57.64543 &gt; 10.7.80.58.1234: P 78972532:78972923(391) ack 12915963 win 255
</span></span></code></pre></td></tr></table>
</div>
</div><p>由于例子中两台主机都在以太网内，以太网的 MTU 为1500，减去 IP 和 TCP 头部的长度，MSS 就是 1460，三次握手中，SYN 包都会携带期望的 MSS 大小。</p>
<p>所以当应用层调用 TCP 层提供的发送方法时，内核的 TCP 模块在 tcp_sendmsg 方法里，按照对方告知的 MSS 来分片，把消息流分为多个 MSS 分组。</p>
<p><strong>TCP 的 MSS 分片大小是固定的吗？</strong></p>
<p>不是。MSS 为了避免 IP 层分片，在建立握手时告知对方期望接收的 MSS 值并不一定靠得住。为什么？</p>
<p>因为这个值是预估的，真实的 MSS 大小取决于路径 MTU，什么是路径 MTU？就是报文途径路由节点里最小的 MTU。</p>
<p>那怎么确定真实 MSS 大小呢？通过设置 IP 头部的 DF 标志位，告诉所有途经路由的 IP 层代码：不要对这个报文分片。如果一个 IP 报文太大必须要分片，则直接返回一个 ICMP 错误（说明必须要分片了），且包含待分片路由器网络接受的 MTU 值。这样，连接的发送方主机就可以重新确定 MSS。</p>
<h2 id="发送数据的各种问题">发送数据的各种问题</h2>
<p><strong>阻塞套接字，假设内核缓冲区还剩下 100 字节</strong></p>
<ul>
<li>发送100字节，立即返回，返回成功写入字节数100</li>
<li>发送101字节，并且设置了SO_SNDTIMEO（假设是5），内核缓冲区一直没腾出空间空间，最终会返回写入成功的字节数100，errno等于110（ETIMEDOUT）。</li>
<li>发送101字节，如果内核空闲出来空间了，就会完整复制101字节到内核，然后立即返回。</li>
<li>如果内核没空间了，没复制任何字节到内核，就返回-1，errno 等于 EAGIN</li>
<li>如果被信号中断了，会返回 -1，errno等于4（EINTR）</li>
</ul>
<p><strong>非阻塞套接字，假设内核缓冲区还剩下 100 字节</strong></p>
<ul>
<li>发送100字节，立即返回，返回成功写入字节数 100</li>
<li>发送101字节，由于空间不够，返回 -1，errno 取值 EAGAIN。</li>
</ul>
<p><strong>发送方法返回成功后，数据一定到了另一端吗？</strong></p>
<p>当然不是。因为当调用发送方法时，内核只会把用户态的数据分装成一个又一个 MSS 大小的包，然后放到 TCP 发送队列后就返回了。</p>
<p>如果队列满了怎么办呢？这要看套接字是不是阻塞的。</p>
<ul>
<li>如果是阻塞的，并且设置了 SO_SNDTIMEO，假设为 5，那么 5 秒后，内核缓冲区还没足够的空间容纳整个发送报文，那么会返回已复制的字节数或者 -1，errno 等于 110（ETIMEDOUT）</li>
<li>如果是非阻塞的，将忽略 SO_SNDTIMEO 选项，直接返回已复制到内核的字节数，如果没有空间了就返回 -1，errno 等于 11（EAGAIN）</li>
</ul>
<p><strong>内核中的报文到底什么时候发出去呢？</strong></p>
<p>发送是由内核的软中断线程异步进行的。在发送过程中也会有一系列条件的检查，如果不满足也不会发送出去：</p>
<ul>
<li>检查一：因为有慢启动和拥塞控制的存在，所以真正能发出去的数据大小 &lt;= min(发送窗口，拥塞窗口)</li>
<li>检查二：如果开启了 Nagle 算法，小于 MSS 的包会缓存起来，直到积累够一个 MSS 大小的包或者超时（假设200ms），并且网络中最多飞行一个未确认的报文，才会把数据包发出去，所以对时延要求比较高的服务，需要关闭 Nagle 算法。</li>
</ul>
<p><strong>什么是慢启动呢？</strong></p>
<p>说白了，就是对方通告的窗口大小只表示对方接收 TCP 分组的能力，不表示中间网络能够处理分组的能力。所以，发送方请悠着点发，确保网络非常通畅了后（通过慢启动算法），再按照对方通告的窗口敞开了去发。</p>
<p><strong>对一个收到 FIN 或 RST 的套接字写数据会怎样？</strong></p>
<ul>
<li>对方发来 FIN，代表对端数据发完了，不代表我们发完了，所以还可以写</li>
<li>对方发来 RST，那么 TCP 连接就直接销毁了，对已销毁的连接发送数据，会返回 -1，errno 等于 104（ECONNRESET）。注意，当再次调用发送方法，内核就会发送 SIGPIPE 信号给进程，如果没有捕捉，那么该信号的默认行为是杀死进程。</li>
</ul>
<h2 id="发送方法的原子性和线程安全">发送方法的原子性和线程安全</h2>
<p>发送方法是原子的，也就是说，写了 1000 字节，返回值是 1000，那么在这 1000 字节的报文中间，不会有别的内容穿插进来。</p>
<p>但短写（short write）导致即使是原子操作也存在安全问题，短写就是返回的字节数比要发送的字节数小。</p>
<p>如果出现实际发送值小于请求值（short write）的情况，此时该线程返回，按照一般的设计逻辑会采用循环 send 直到发送值总和等于请求值，那么此时该线程又会和其他线程同时竞争发送，就可能与其他线程的数据交错。所以即使是原子操作，因为短写的问题也是存在安全隐患的。</p>
<p>一般采用的循环发送伪码如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">while(sendlen &lt; querylen){ // 循环保证实际发送值等于请求值
</span></span><span class="line"><span class="cl">    sendlen += send(buf, querylen - sendlen);
</span></span><span class="line"><span class="cl">	buf + sendlen;
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>也不能对写操作整体加锁，假如加锁，而又发生 short write，就要等到整条消息发送完才解锁（无论阻塞 IO 还是非阻塞 IO）。</p>
<p>如此，临界区加锁时长由对端接收数据能力来决定，一个慢的 peer 就把发送程序搞死了。</p>
<h2 id="接收数据的各种问题">接收数据的各种问题</h2>
<p><strong>SO_RCVLOWAT 选项是如何影响读取的？</strong></p>
<p>就是要求内核拷贝字节数必须大于等于 SO_RCVLOWAT，才能从 recv 系统调用返回。</p>
<p>这个值在 Linux 等系统中，默认是 1。也就是说，只要有一个字节可读就立即返回。</p>
<p>如果在多路复用中，套接字读缓冲区字节数必须大于等于 SO_RCVLOWAT，才意味着可读。</p>
<p><strong>对一个收到 FIN 或 RST 的套接字读取会怎样？</strong></p>
<p>可能出现两种情况：</p>
<ul>
<li>recv 返回 0，代表对方发送了 FIN 过来，可能是进程异常退出、调用了 close 或者 shutdown（半关闭写）。</li>
<li>recv 返回 -1，errno 等于 104（ECONNRESET），代表对方发送 RST 重置了连接。</li>
</ul>
<h1 id="关闭-socket">关闭 socket</h1>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">#include &lt;unistd.h&gt;
</span></span><span class="line"><span class="cl">int close(int fd);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">#include &lt;sys/socket.h&gt;
</span></span><span class="line"><span class="cl">int shutdown(int sockfd, int how);
</span></span></code></pre></td></tr></table>
</div>
</div><p>shutdown 函数 how 参数取值：</p>
<ul>
<li>SHUT_RDWR 关闭读写</li>
<li>SHUT_WR 关闭写</li>
<li>SHUT_RD 关闭读</li>
</ul>
<p>函数调用成功返回 0，失败返回 -1</p>
<h2 id="close-监听套接字">close 监听套接字</h2>
<ol>
<li>移除 keepalive 定时器。keepalive 功能常用于服务器上，防止僵死、异常退出的客户端占用服务器连接资源。移除此定时器后，若ESTABLISH状态的TCP连接在tcp_keepalive_time时间（如服务器上常配置为2小时）内没有通讯，服务器就会主动关闭连接。</li>
<li>销毁每个 SYN_RECV 状态的 TCP 连接（销毁的对象半连接队列，而不会发送 RST 报文，等客户端再次发来 SYN 或者 ACK后，会收到 RST 重置报文）；</li>
<li>发送 RST 报文到所有 ESTABLISH 状态且没有 accept 的 TCP 连接（发 RST 重置报文的对象是全连接队列）。</li>
</ol>
<h2 id="close-连接套接字">close 连接套接字</h2>
<ol>
<li>关闭的连接会交由内核接管；</li>
<li>当发送缓冲区不为空时：把 FIN 标志位放到最后一个数据包中，否则就构造一个 FIN 数据包；</li>
<li>当接收缓冲区不为空时：发送 RST + ACK 到对端，告知对方自己这边处理异常了（进程崩溃等原因造成）。然后客户端和服务端的套接字不会走四次挥手，而是直接销毁连接。</li>
<li>其它情况下，正常走四次挥手。</li>
</ol>
<h2 id="so_linger-这个选项的用处在哪">SO_LINGER 这个选项的用处在哪？</h2>
<p>SO_LINGER 选项可以解决两个问题：</p>
<ol>
<li>省去 TCP 挥手过程，等待时间设置为 0 可以跳过 TCP 连接 TIME_WAIT 状态；</li>
<li>直到发送窗口的数据全部被对端确认，才从 close 调用返回，或者超时返回。</li>
</ol>
<p>那等待时间设置为 0 可能出现的问题就是：</p>
<ol>
<li>客户端发送 包1</li>
<li>客户端发送 包2</li>
<li>客户端调用 close 关闭套接字，内核会销毁该连接（不会维护丢包重传这些功能），然后丢弃还未确认的发送缓冲区，并发送 RST + ACK 到服务器。</li>
</ol>
<p>服务器运气好的情况下，包1 包2 都能正确收到。运气不好的情况下，可能一个包都收不到。</p>
<p>什么时候可以把等待时间设置为0呢？当主动关闭的一方确定了对端已经完整接收了所有数据时（比如对端响应 ok），可以用 RST 暴力关闭不会出问题。</p>
<h2 id="close-和-shutdown-的区别">close 和 shutdown 的区别</h2>
<p>就两点</p>
<ol>
<li>close 把文件描述符引用计数 -1，如果为 0 就走 TCP 挥手过程</li>
<li>shutdown 跳过了引用计数的判断，直接走四次挥手，但还要调用 close 关闭文件描述符</li>
</ol>
<p><strong>什么情况下使用 shutdown 呢？</strong></p>
<p>讲一个透传代理的例子。</p>
<p>我们知道，recv(client_fd, &hellip;) 返回 0 表示你收到了对方发来的 FIN，这可能是对方调用了 shutdown(write)，也可能是对方调用了 close()，这只能说明对端没数据写了，不代表不接收数据。所以此时是否要 close() 取决于你的应用。通常来说如果对方调用的是 close()，那么你也可以 close()，否则你不能 close()。</p>
<p>例如对方发送一个包给你并 shutdown(write)，然后调用 recv()，此时对方连接处于半关闭状态，但可以一直持续接收数据。</p>
<p>如果此时你调用了 close()，那么对方就会收到 FIN，然后 recv 调用返回 0，导致客户端退出。</p>
<p>所以正确做法是什么呢？</p>
<p>在讨论正确的做法下，我们先讨论下收到 FIN 的语义，其实就是代表对方没数据可写了，关闭了写端。所以我们只要精确传达语义，把这个行为用 shutdown(server_fd, write) 透传给另外一端即可。我们依然可以收到 server_fd 的数据并回传给 client_fd。</p>
<p>那什么时候才能 close 呢？</p>
<p>当 client_socket 和 server_socket 双方的 read 都返回了0，或者有任何一方返回了 -1 时就可以 close()。</p>

    </div>

    
<footer class="post-footer">
      
      <nav class="post-nav">
        <a class="prev" href="/post/%E9%AB%98%E6%80%A7%E8%83%BD%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-%E7%BD%91%E7%BB%9C%E6%A1%86%E6%9E%B6%E8%AE%BE%E8%AE%A1/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">高性能网络编程 - 网络框架设计</span>
            <span class="prev-text nav-mobile">Prev</span>
          </a>
        <a class="next" href="/post/%E9%AB%98%E6%80%A7%E8%83%BD%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-io-%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/">
            <span class="next-text nav-default">高性能网络编程 - IO 多路复用</span>
            <span class="next-text nav-mobile">Next</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
  <a href="http://blog.gongchang.me/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    Powered by <a class="hexo-link" href="https://gohugo.io">Hugo</a>
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    Theme - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2017 - 
    2022<span class="heart"><i class="iconfont icon-heart"></i></span><span>olOwOlo</span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script><script></script><script src="https://cdn.jsdelivr.net/npm/raphael@2.2.7/raphael.min.js" integrity="sha256-67By+NpOtm9ka1R6xpUefeGOY8kWWHHRAKlvaTJ7ONI=" crossorigin="anonymous"></script> <script src="https://cdn.jsdelivr.net/npm/flowchart.js@1.8.0/release/flowchart.min.js" integrity="sha256-zNGWjubXoY6rb5MnmpBNefO0RgoVYfle9p0tvOQM+6k=" crossorigin="anonymous"></script><script></script><script src="https://cdn.jsdelivr.net/npm/webfontloader@1.6.28/webfontloader.js" integrity="sha256-4O4pS1SH31ZqrSO2A/2QJTVjTPqVe+jnYgOWUVr7EEc=" crossorigin="anonymous"></script> <script src="https://cdn.jsdelivr.net/npm/snapsvg@0.5.1/dist/snap.svg-min.js" integrity="sha256-oI+elz+sIm+jpn8F/qEspKoKveTc5uKeFHNNVexe6d8=" crossorigin="anonymous"></script> <script src="https://cdn.jsdelivr.net/npm/underscore@1.8.3/underscore-min.js" integrity="sha256-obZACiHd7gkOk9iIL/pimWMTJ4W/pBsKu+oZnSeBIek=" crossorigin="anonymous"></script> <script src="https://cdn.jsdelivr.net/gh/bramp/js-sequence-diagrams@2.0.1/dist/sequence-diagram-min.js" integrity="sha384-8748Vn52gHJYJI0XEuPB2QlPVNUkJlJn9tHqKec6J3q2r9l8fvRxrgn/E5ZHV0sP" crossorigin="anonymous"></script>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/bramp/js-sequence-diagrams@2.0.1/dist/sequence-diagram-min.css" integrity="sha384-6QbLKJMz5dS3adWSeINZe74uSydBGFbnzaAYmp+tKyq60S7H2p6V7g1TysM5lAaF" crossorigin="anonymous">



<script type="text/javascript" src="/js/main.min.4ae89da218555efa0e7093a20b92017d2e1202b66fff9fc2edf4cb8d44b44c6e.js"></script>








</body>
</html>
