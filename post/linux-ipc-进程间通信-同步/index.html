<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>Linux IPC 进程间通信 &amp; 同步 - 弓长笔记</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="jincheng9" /><meta name="description" content="前言 当我们进行多进程编程时，免不了在多个进程之间进行数据的共享和通信，而这些方法都由系统内核提供。并且在演化的过程中，出现了三个名词： System V 当" /><meta name="keywords" content="Hugo, theme, even" />






<meta name="generator" content="Hugo 0.101.0 with theme even" />


<link rel="canonical" href="http://blog.gongchang.me/post/linux-ipc-%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1-%E5%90%8C%E6%AD%A5/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.b5a744db6de49a86cadafb3b70f555ab443f83c307a483402259e94726b045ff.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:title" content="Linux IPC 进程间通信 &amp; 同步" />
<meta property="og:description" content="前言 当我们进行多进程编程时，免不了在多个进程之间进行数据的共享和通信，而这些方法都由系统内核提供。并且在演化的过程中，出现了三个名词： System V 当" />
<meta property="og:type" content="article" />
<meta property="og:url" content="http://blog.gongchang.me/post/linux-ipc-%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1-%E5%90%8C%E6%AD%A5/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2022-02-28T23:09:31+08:00" />
<meta property="article:modified_time" content="2022-02-28T23:09:31+08:00" />

<meta itemprop="name" content="Linux IPC 进程间通信 &amp; 同步">
<meta itemprop="description" content="前言 当我们进行多进程编程时，免不了在多个进程之间进行数据的共享和通信，而这些方法都由系统内核提供。并且在演化的过程中，出现了三个名词： System V 当"><meta itemprop="datePublished" content="2022-02-28T23:09:31+08:00" />
<meta itemprop="dateModified" content="2022-02-28T23:09:31+08:00" />
<meta itemprop="wordCount" content="13882">
<meta itemprop="keywords" content="" /><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Linux IPC 进程间通信 &amp; 同步"/>
<meta name="twitter:description" content="前言 当我们进行多进程编程时，免不了在多个进程之间进行数据的共享和通信，而这些方法都由系统内核提供。并且在演化的过程中，出现了三个名词： System V 当"/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">弓长笔记</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">主页</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">全部文章</li>
      </a><a href="/about/">
        <li class="mobile-menu-item">关于</li>
      </a>
  </ul>

  


</nav>

  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">弓长笔记</a>
</div>





<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">主页</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">全部文章</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/about/">关于</a>
      </li>
  </ul>
</nav>

    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">Linux IPC 进程间通信 &amp; 同步</h1>

      <div class="post-meta">
        <span class="post-time"> 2022-02-28 </span>
        
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">Contents</h2>
  <div class="post-toc-content always-active">
    <nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#前言">前言</a></li>
        <li><a href="#ftok-函数的作用">ftok 函数的作用</a></li>
        <li><a href="#本地套接字unix-socket">本地套接字（Unix Socket）</a>
          <ul>
            <li><a href="#字节流套接字-vs-数据报套接字">字节流套接字 vs 数据报套接字</a></li>
            <li><a href="#全双工本地匿名套接字">全双工本地匿名套接字</a></li>
          </ul>
        </li>
        <li><a href="#管道pipe">管道（PIPE）</a>
          <ul>
            <li><a href="#匿名管道">匿名管道</a></li>
            <li><a href="#命名管道">命名管道</a></li>
          </ul>
        </li>
        <li><a href="#普通文件共享数据">普通文件共享数据</a>
          <ul>
            <li><a href="#flock-api-解决竞态">flock API 解决竞态</a></li>
            <li><a href="#lockf-api-解决竞态">lockf API 解决竞态</a></li>
            <li><a href="#flock-命令实现程序只运行一次">flock 命令实现程序只运行一次</a></li>
          </ul>
        </li>
        <li><a href="#共享内存">共享内存</a>
          <ul>
            <li><a href="#mmap-共享内存">mmap 共享内存</a></li>
            <li><a href="#xsi-共享内存">XSI 共享内存</a></li>
            <li><a href="#posix-共享内存">POSIX 共享内存</a></li>
          </ul>
        </li>
        <li><a href="#消息队列">消息队列</a>
          <ul>
            <li><a href="#xsi-消息队列">XSI 消息队列</a></li>
            <li><a href="#posix-消息队列">POSIX 消息队列</a></li>
          </ul>
        </li>
        <li><a href="#信号量">信号量</a>
          <ul>
            <li><a href="#xsi-信号量">XSI 信号量</a></li>
            <li><a href="#posix-命名信号量">POSIX 命名信号量</a></li>
            <li><a href="#posix-匿名信号量">POSIX 匿名信号量</a></li>
          </ul>
        </li>
      </ul>
    </li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <h2 id="前言">前言</h2>
<p>当我们进行多进程编程时，免不了在多个进程之间进行数据的共享和通信，而这些方法都由系统内核提供。并且在演化的过程中，出现了三个名词：</p>
<ul>
<li><strong>System V</strong> 当我们说编程接口符合 System V，也就是符合早期 Unix 操作系统的编程接口；</li>
<li><strong>POSIX</strong>  是由 IEEE 制定的标准，全称是（Portable Operating System Interface for Computing Systems）。在兼容 System V 接口的基础上，又制定了很多新的接口标准。</li>
<li><strong>XSI</strong> （X/Open System Interface），是 POSIX 标准的超集，定义了一些附加的接口的标准。比如文件同步，存储映射文件，存储保护及线程接口。只有遵循 XSI 的实现才能称为现代 Unix 操作系统。</li>
</ul>
<p>所以我们在讨论 IPC 进程间通信时，其实讨论的是 POSIX 和 XSI 两套接口标准的使用方法。</p>
<p>简单说，POSIX 和 XSI 两套接口的区别主要体现在，</p>
<ol>
<li>共享内存：XSI 使用 ipcs -m 命令管理；POSIX 使用文件系统 /dev/shm/ 管理。</li>
<li>消息队列：XSI 使用 ipcs -q 命令管理；POSIX 使用文件系统 /dev/mqueue/ 管理。</li>
<li>信号量：XSI 使用 ipcs -s 命令管理；POSIX 使用文件系统 /dev/shm/ 管理。</li>
</ol>
<h2 id="ftok-函数的作用">ftok 函数的作用</h2>
<p>在讨论之前，我们先介绍一个 ftok API，系统在进行 XSI (System V) 的共享内存、消息队列、信号量编程时，都需要调用 ftok 生成一个唯一 key。用这个 key 作为资源的标识符。</p>
<p><strong>ftok 函数原型如下：</strong></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">#include &lt;sys/types.h&gt;
</span></span><span class="line"><span class="cl">#include &lt;sys/ipc.h&gt;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">key_t ftok(const char *pathname, int proj_id);
</span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>第一个参数，pathname 该文件必须是存在而且可以访问的</li>
<li>第二个参数，proj_id 是子序号，子序号不同返回值也不同，虽然为 int，但实际只有 8 个比特被使用(0-255)</li>
<li>而 key_t 则是一个 32 位整数类型</li>
</ul>
<p><big><strong>ftok 函数的实现原理</strong></big></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">#include&lt;stdio.h&gt;
</span></span><span class="line"><span class="cl">#include&lt;stdlib.h&gt;
</span></span><span class="line"><span class="cl">#include&lt;unistd.h&gt;
</span></span><span class="line"><span class="cl">#include&lt;sys/types.h&gt;
</span></span><span class="line"><span class="cl">#include&lt;sys/stat.h&gt;
</span></span><span class="line"><span class="cl">#include&lt;sys/ipc.h&gt;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">#define PROJ_MASK 0x000000ff
</span></span><span class="line"><span class="cl">#define INODE_MASK 0x0000ffff
</span></span><span class="line"><span class="cl">#define MINOR_MASK 0x000000ff
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">key_t ipc_ftok(const char *pathname, int proj_id)
</span></span><span class="line"><span class="cl">{
</span></span><span class="line"><span class="cl">    struct stat buf;
</span></span><span class="line"><span class="cl">    long minor_id = 0L, inode_id = 0L;
</span></span><span class="line"><span class="cl">    key_t key = 0;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    if(stat(pathname, &amp;buf) == -1 || !proj_id) {
</span></span><span class="line"><span class="cl">        return -1;
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">    minor_id = (long)minor(buf.st_dev);
</span></span><span class="line"><span class="cl">    inode_id = (long)buf.st_ino;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    key = inode_id &amp; INODE_MASK;
</span></span><span class="line"><span class="cl">    key |= (minor_id &amp; MINOR_MASK) &lt;&lt; 16;
</span></span><span class="line"><span class="cl">    key |= (proj_id &amp; PROJ_MASK) &lt;&lt; 24;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    return key;
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">int main()
</span></span><span class="line"><span class="cl">{
</span></span><span class="line"><span class="cl">    int i = 0;
</span></span><span class="line"><span class="cl">    for ( i = 1; i &lt; 256; ++ i ) {
</span></span><span class="line"><span class="cl">        printf(&#34;proj_id %d, key = %x, my ftok key= %x\n&#34;, i, ftok( &#34;/etc/passwd&#34;, i ), ipc_ftok( &#34;/etc/passwd&#34;, i ) );
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    return 0;
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p><strong>运行程序：</strong></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">proj_id 1, key = 10066c9, my ftok key= 10066c9
</span></span><span class="line"><span class="cl">proj_id 2, key = 20066c9, my ftok key= 20066c9
</span></span><span class="line"><span class="cl">proj_id 3, key = 30066c9, my ftok key= 30066c9
</span></span><span class="line"><span class="cl">...
</span></span><span class="line"><span class="cl">proj_id 253, key = fd0066c9, my ftok key= fd0066c9
</span></span><span class="line"><span class="cl">proj_id 254, key = fe0066c9, my ftok key= fe0066c9
</span></span><span class="line"><span class="cl">proj_id 255, key = ff0066c9, my ftok key= ff0066c9
</span></span></code></pre></td></tr></table>
</div>
</div><p><strong>实现原理就是：</strong></p>
<ul>
<li>获取文件的设备号 ID，存储在 st_dev 字段；</li>
<li>获取文件的 inode 编号，存储在 st_ino 字段；</li>
<li>然后和 proj_id 参数做一些简单位移操作，即得到了唯一标识符。</li>
</ul>
<p><strong>所以在使用的时候，要注意两点：</strong></p>
<ul>
<li>文件最好不要修改或者删除，因为 inode 容易改变，那么 fotk 返回的 key 可能每次都不一样。最好使用不经常变的文件，如 /etc/passwd、/etc/group；</li>
<li>文件也不要用 vi、vim、emacs 编辑器操作，否则 inode 节点可能会变，也将导致 ftok 生成的 key_t 随之改变。</li>
</ul>
<h2 id="本地套接字unix-socket">本地套接字（Unix Socket）</h2>
<p><strong>本地套接字和网络套接字的区别：</strong></p>
<ul>
<li>本地套接字只是绑定在一个文件，文件必须能创建和访问；</li>
<li>本地套接字不走回环接口，也就是说，把回环接口关了，localhost、127.0.0.1 就不能通信了，而本地套接字不受影响；</li>
<li>本地套接字支持进程间传递文件描述符，这种功能，没有其它接口可以做到。</li>
</ul>
<p>唯一相同的就是，TCP、UDP 套接字怎么编程，本地套接字也怎么编程，模式都一样。</p>
<h3 id="字节流套接字-vs-数据报套接字">字节流套接字 vs 数据报套接字</h3>
<p>很多知名软件，如 MySQL、Redis，他们为了高效率，也都提供本地套接字的连接方式。</p>
<p><strong>服务端代码</strong></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span><span class="lnt">70
</span><span class="lnt">71
</span><span class="lnt">72
</span><span class="lnt">73
</span><span class="lnt">74
</span><span class="lnt">75
</span><span class="lnt">76
</span><span class="lnt">77
</span><span class="lnt">78
</span><span class="lnt">79
</span><span class="lnt">80
</span><span class="lnt">81
</span><span class="lnt">82
</span><span class="lnt">83
</span><span class="lnt">84
</span><span class="lnt">85
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">#include &lt;stdio.h&gt;
</span></span><span class="line"><span class="cl">#include &lt;unistd.h&gt;
</span></span><span class="line"><span class="cl">#include &lt;string.h&gt;
</span></span><span class="line"><span class="cl">#include &lt;stdlib.h&gt;
</span></span><span class="line"><span class="cl">#include &lt;errno.h&gt;
</span></span><span class="line"><span class="cl">#include &lt;sys/types.h&gt;
</span></span><span class="line"><span class="cl">#include &lt;signal.h&gt;
</span></span><span class="line"><span class="cl">#include &lt;sys/socket.h&gt;
</span></span><span class="line"><span class="cl">#include &lt;sys/un.h&gt;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">#define UNIX_SOCKET_NAME &#34;unixsock.sock&#34;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">void echo_cli(int sock)
</span></span><span class="line"><span class="cl">{
</span></span><span class="line"><span class="cl">    char buf[1024] = {0};
</span></span><span class="line"><span class="cl">    int ret = 0;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    while(1) {
</span></span><span class="line"><span class="cl">        ret = read(sock, buf, sizeof(buf));
</span></span><span class="line"><span class="cl">        if(ret == 0) {
</span></span><span class="line"><span class="cl">            printf(&#34;client %d close...\n&#34;, sock);
</span></span><span class="line"><span class="cl">            break;
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">        write(sock, buf, strlen(buf));
</span></span><span class="line"><span class="cl">        memset(buf, 0, sizeof(buf));
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">    close(sock);
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">int main()
</span></span><span class="line"><span class="cl">{
</span></span><span class="line"><span class="cl">    int listenfd = socket(PF_UNIX, SOCK_STREAM, 0);
</span></span><span class="line"><span class="cl">    if(listenfd &lt; 0) {
</span></span><span class="line"><span class="cl">        perror(&#34;socket error: &#34;);
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    unlink(UNIX_SOCKET_NAME);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    struct sockaddr_un serv_addr = {0};
</span></span><span class="line"><span class="cl">    serv_addr.sun_family = AF_UNIX;
</span></span><span class="line"><span class="cl">    strncpy(serv_addr.sun_path, UNIX_SOCKET_NAME, sizeof(serv_addr.sun_path));
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    int reuse = 1;
</span></span><span class="line"><span class="cl">    if(setsockopt(listenfd, SOL_SOCKET, SO_REUSEADDR, &amp;reuse, sizeof(reuse)) &lt; 0) {
</span></span><span class="line"><span class="cl">        perror(&#34;setsockopt error: &#34;);
</span></span><span class="line"><span class="cl">        return 1;
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    if(bind(listenfd, (struct sockaddr *)&amp;serv_addr, sizeof(serv_addr)) &lt; 0) {
</span></span><span class="line"><span class="cl">        perror(&#34;bind error: &#34;);
</span></span><span class="line"><span class="cl">        return 1;
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    if(listen(listenfd, SOMAXCONN) &lt; 0) {
</span></span><span class="line"><span class="cl">        perror(&#34;listern error: &#34;);
</span></span><span class="line"><span class="cl">        return 1;
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    pid_t pid = {0};
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    while(1) {
</span></span><span class="line"><span class="cl">        int conn = 0;
</span></span><span class="line"><span class="cl">        if ((conn = accept(listenfd, NULL, NULL)) &lt; 0) {
</span></span><span class="line"><span class="cl">            if(errno == EINTR) {
</span></span><span class="line"><span class="cl">                continue;
</span></span><span class="line"><span class="cl">            }
</span></span><span class="line"><span class="cl">            perror(&#34;accept error: &#34;);
</span></span><span class="line"><span class="cl">            break;
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        printf(&#34;New client connected, conn = %d\n&#34;, conn);
</span></span><span class="line"><span class="cl">        pid = fork();
</span></span><span class="line"><span class="cl">        if(pid &lt; 0) {
</span></span><span class="line"><span class="cl">            perror(&#34;fork error: &#34;);
</span></span><span class="line"><span class="cl">        } else if(pid == 0) { //child process
</span></span><span class="line"><span class="cl">            echo_cli(conn);
</span></span><span class="line"><span class="cl">            exit(0);
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        /* parent process */
</span></span><span class="line"><span class="cl">        close(conn);
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    return 0;
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>上面的程序实现了：监听本地套接字，如果新的客户端到来，创建一个子进程，并循环处理 echo 回声服务。</p>
<p>编译运行程序后，会在当前目录下产生一个类型为 s 的文件（代表本地套接字文件）：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">$ ls -l unixsock.sock
</span></span><span class="line"><span class="cl">srwxr-xr-x. 1 root root 0 2月  11 18:37 unixsock.sock
</span></span></code></pre></td></tr></table>
</div>
</div><p>另外注意，unixsock.sock 本地套接字文件是在调用了 bind 之后被创建的，而不是在 listen 之后。</p>
<p><big><strong>数据报套接字</strong></big></p>
<p>其实就是用的 UDP 编程那套模式，发送数据是 sento，接收数据是 recvfrom。就不多详细多介绍了。</p>
<p>具体在编程中，更推荐使用<strong>字节流套接字</strong>，如果非说一个原因，就是不容易出错。为什么呢？简单来说，前者缓冲区有 100 字节，我们读了 20 字节，而后还能再读出 80 字节。而后者可能就读不出 80 字节了，归根原理，是 UDP 数据包的有界性导致。</p>
<h3 id="全双工本地匿名套接字">全双工本地匿名套接字</h3>
<p>socketpair 可以创建一对匿名的本地套接字，方便之处在于：</p>
<ul>
<li>不需要指定文件路径；</li>
<li>支持字节流、数据报两种模式；</li>
<li>全双工（每一端都可以进行读和写操作），这一点和管道半双工（每一端只能进行读或者写操作）不同。</li>
</ul>
<p><strong>代码示例</strong></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">#include &lt;stdio.h&gt;
</span></span><span class="line"><span class="cl">#include &lt;string.h&gt;
</span></span><span class="line"><span class="cl">#include &lt;unistd.h&gt;
</span></span><span class="line"><span class="cl">#include &lt;sys/types.h&gt;
</span></span><span class="line"><span class="cl">#include &lt;error.h&gt;
</span></span><span class="line"><span class="cl">#include &lt;errno.h&gt;
</span></span><span class="line"><span class="cl">#include &lt;sys/socket.h&gt;
</span></span><span class="line"><span class="cl">#include &lt;stdlib.h&gt;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">const char* str = &#34;SOCKET PAIR TEST.&#34;;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">int main(int argc, char* argv[]){
</span></span><span class="line"><span class="cl">    char buf[128] = {0};
</span></span><span class="line"><span class="cl">    int socket_pair[2];
</span></span><span class="line"><span class="cl">    int size;
</span></span><span class="line"><span class="cl">    pid_t pid;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    if(socketpair(AF_UNIX, SOCK_STREAM, 0, socket_pair) == -1 ) {
</span></span><span class="line"><span class="cl">        printf(&#34;Error, socketpair create failed, errno(%d): %s\n&#34;, errno, strerror(errno));
</span></span><span class="line"><span class="cl">        return EXIT_FAILURE;
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    size = write(socket_pair[0], str, strlen(str));
</span></span><span class="line"><span class="cl">    read(socket_pair[1], buf, size);
</span></span><span class="line"><span class="cl">    printf(&#34;Read result: %s\n&#34;,buf);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    size = write(socket_pair[1], str, strlen(str));
</span></span><span class="line"><span class="cl">    read(socket_pair[0], buf, size);
</span></span><span class="line"><span class="cl">    printf(&#34;Read result: %s\n&#34;,buf);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    return EXIT_SUCCESS;
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>上面代码种，socketpair 创建的两个匿名本地套接字，会存储在 socket_pair[2] 数组中。</p>
<p>然后查看进程打开的文件描述符列表，可以看到，最后两行的文件描述符 3 和 4 就是通过 socketpair 创建出来的 unix 套接字。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">$ lsof -p 58747
</span></span><span class="line"><span class="cl">COMMAND   PID USER   FD   TYPE             DEVICE SIZE/OFF     NODE NAME
</span></span><span class="line"><span class="cl">...
</span></span><span class="line"><span class="cl">a.out   58747 root    0u   CHR              136,4      0t0        7 /dev/pts/4
</span></span><span class="line"><span class="cl">a.out   58747 root    1u   CHR              136,4      0t0        7 /dev/pts/4
</span></span><span class="line"><span class="cl">a.out   58747 root    2u   CHR              136,4      0t0        7 /dev/pts/4
</span></span><span class="line"><span class="cl">a.out   58747 root    3u  unix 0xffff90532a5fe600      0t0   398611 socket
</span></span><span class="line"><span class="cl">a.out   58747 root    4u  unix 0xffff90532a5ffb40      0t0   398612 socket
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="管道pipe">管道（PIPE）</h2>
<p>匿名管道和命名管道最大的区别：匿名只能用于父子进程间通信，而命名的才可以多进程间通信。</p>
<p>管道既然作为一种文件描述符存在，也是可以被 select、poll、epoll 此类 API 使用的，可以监控管道是否可写，是否可读。</p>
<p><big><strong>管道写入的原子性？</strong></big></p>
<p>POSIX 规定</p>
<ul>
<li>少于 PIPE_BUF 的写操作必须原子完成，写入连续；</li>
<li>大于 PIPE_BUF 的写操作可能是非原子的: 内核可能会把此数据与其它进程的对此管道的写操作交替进行；</li>
<li>并且 PIPE_BUF 至少为 512 字节 (Linux 中为 4096 字节)。</li>
</ul>
<p>所以：</p>
<ul>
<li>当要写入的数据量 &lt;= PIPE_BUF时，Linux 保证写入的原子性。</li>
<li>当要写入的数据量 &gt; PIPE_BUF时，Linux 不保证写入的原子性。</li>
</ul>
<p><big><strong>什么情况下操作管道会堵塞？</strong></big></p>
<p>如果是非阻塞模式下，任何时候写入和读取都不会阻塞：</p>
<ul>
<li>如果管道满，则 write 失败，返回错误，并将 errno 设置为 EAGIN。如果不满，则返回写入的字节数为 1~n，即部分写入，写入时可能有其他进程穿插写入。</li>
</ul>
<p>把管道设置为非阻塞模式的代码：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">int setNonBlock(int fd) {
</span></span><span class="line"><span class="cl">    if(fcntl(fd, F_SETFL, fcntl(fd, F_GETFL, 0) | O_NONBLOCK) &lt; 0) {
</span></span><span class="line"><span class="cl">        perror(&#34;fcntl F_SETFL&#34;);
</span></span><span class="line"><span class="cl">        return -1;
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">    return 0;
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>如果是阻塞模式：</p>
<ul>
<li>管道为空，进程调用 read 会陷入阻塞，直到有进程 write 数据到管道；</li>
<li>默认管道大小是 PIPE_SIZE (Linux 中是 65535 字节)，假设已经写入了 65000 字节，还剩 535 字节，此时进程若再写入 536 字节的数据会陷入阻塞。</li>
</ul>
<p>查看和设置管道容量（PIPE_SIZE）大小：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">#define _GNU_SOURCE
</span></span><span class="line"><span class="cl">#include &lt;stdlib.h&gt;
</span></span><span class="line"><span class="cl">#include &lt;stdio.h&gt;
</span></span><span class="line"><span class="cl">#include &lt;unistd.h&gt;
</span></span><span class="line"><span class="cl">#include &lt;string.h&gt;
</span></span><span class="line"><span class="cl">#include &lt;fcntl.h&gt;
</span></span><span class="line"><span class="cl">#include &lt;errno.h&gt;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">int main()
</span></span><span class="line"><span class="cl">{
</span></span><span class="line"><span class="cl">    int ret;
</span></span><span class="line"><span class="cl">    int pipefd[2];
</span></span><span class="line"><span class="cl">    int nbytes;
</span></span><span class="line"><span class="cl">    if (pipe(pipefd) == -1) {
</span></span><span class="line"><span class="cl">        perror(&#34;pipe()&#34;);
</span></span><span class="line"><span class="cl">        exit(1);
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    ret = fcntl(pipefd[1], F_GETPIPE_SZ);
</span></span><span class="line"><span class="cl">    if (ret &lt; 0) {
</span></span><span class="line"><span class="cl">        perror(&#34;fcntl()&#34;);
</span></span><span class="line"><span class="cl">        exit(1);
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">    printf(&#34;PIPESIZE: %d\n&#34;, ret);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    ret = fcntl(pipefd[1], F_SETPIPE_SZ, 1);
</span></span><span class="line"><span class="cl">    if (ret &lt; 0) {
</span></span><span class="line"><span class="cl">        perror(&#34;fcntl()&#34;);
</span></span><span class="line"><span class="cl">        exit(1);
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">    printf(&#34;PIPESIZE: %d\n&#34;, ret);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    char wbuf[4096] = {0};
</span></span><span class="line"><span class="cl">    nbytes = write(pipefd[1], wbuf, 4096);
</span></span><span class="line"><span class="cl">    printf(&#34;write nbytes %d, %s\n&#34;, nbytes, strerror(errno));
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    return 0;
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>编译运行输出如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">$ gcc pipe_size.c
</span></span><span class="line"><span class="cl">$ ./a.out
</span></span><span class="line"><span class="cl">PIPESIZE: 65536
</span></span><span class="line"><span class="cl">PIPESIZE: 4096
</span></span><span class="line"><span class="cl">write nbytes 4096, Success
</span></span></code></pre></td></tr></table>
</div>
</div><p>可以看到，</p>
<ul>
<li>PIPE_SIZE 默认是 65536 bytes；</li>
<li>容量最低不小于 4096 bytes，例子中尝试设置了 1，但最终 PIPE_SIZE 还是 4096 bytes。</li>
</ul>
<p><big><strong>管道容量可以设置无限大吗？</strong></big></p>
<p>不可以，由 pipe-max-size 文件参数控制，单位是字节。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">cat /proc/sys/fs/pipe-max-size
</span></span><span class="line"><span class="cl">1048576
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="匿名管道">匿名管道</h3>
<p><strong>父子进程通信示例</strong></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">#include &lt;stdlib.h&gt;
</span></span><span class="line"><span class="cl">#include &lt;stdio.h&gt;
</span></span><span class="line"><span class="cl">#include &lt;unistd.h&gt;
</span></span><span class="line"><span class="cl">#include &lt;string.h&gt;
</span></span><span class="line"><span class="cl">#include &lt;sys/types.h&gt;
</span></span><span class="line"><span class="cl">#include &lt;sys/wait.h&gt;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">#define STRING &#34;hello world!&#34;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">int main()
</span></span><span class="line"><span class="cl">{
</span></span><span class="line"><span class="cl">        int pipefd[2];
</span></span><span class="line"><span class="cl">        pid_t pid;
</span></span><span class="line"><span class="cl">        char buf[BUFSIZ];
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        if (pipe(pipefd) == -1) {
</span></span><span class="line"><span class="cl">                perror(&#34;pipe()&#34;);
</span></span><span class="line"><span class="cl">                exit(1);
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        pid = fork();
</span></span><span class="line"><span class="cl">        if (pid == -1) {
</span></span><span class="line"><span class="cl">                perror(&#34;fork()&#34;);
</span></span><span class="line"><span class="cl">                exit(1);
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        if (pid == 0) {
</span></span><span class="line"><span class="cl">                /* this is child. */
</span></span><span class="line"><span class="cl">                printf(&#34;Child pid is: %d\n&#34;, getpid());
</span></span><span class="line"><span class="cl">                if (read(pipefd[0], buf, BUFSIZ) &lt; 0) {
</span></span><span class="line"><span class="cl">                        perror(&#34;write()&#34;);
</span></span><span class="line"><span class="cl">                        exit(1);
</span></span><span class="line"><span class="cl">                }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">                printf(&#34;%s\n&#34;, buf);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">                bzero(buf, BUFSIZ);
</span></span><span class="line"><span class="cl">                snprintf(buf, BUFSIZ, &#34;Message from child: My pid is: %d&#34;, getpid());
</span></span><span class="line"><span class="cl">                if (write(pipefd[1], buf, strlen(buf)) &lt; 0) {
</span></span><span class="line"><span class="cl">                        perror(&#34;write()&#34;);
</span></span><span class="line"><span class="cl">                        exit(1);
</span></span><span class="line"><span class="cl">                }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        } else {
</span></span><span class="line"><span class="cl">                /* this is parent */
</span></span><span class="line"><span class="cl">                printf(&#34;Parent pid is: %d\n&#34;, getpid());
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">                snprintf(buf, BUFSIZ, &#34;Message from parent: My pid is: %d&#34;, getpid());
</span></span><span class="line"><span class="cl">                if (write(pipefd[1], buf, strlen(buf)) &lt; 0) {
</span></span><span class="line"><span class="cl">                        perror(&#34;write()&#34;);
</span></span><span class="line"><span class="cl">                        exit(1);
</span></span><span class="line"><span class="cl">                }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">                sleep(1);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">                bzero(buf, BUFSIZ);
</span></span><span class="line"><span class="cl">                if (read(pipefd[0], buf, BUFSIZ) &lt; 0) {
</span></span><span class="line"><span class="cl">                        perror(&#34;write()&#34;);
</span></span><span class="line"><span class="cl">                        exit(1);
</span></span><span class="line"><span class="cl">                }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">                printf(&#34;%s\n&#34;, buf);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">                wait(NULL);
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        exit(0);
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p><strong>代码说明：</strong></p>
<ul>
<li>pipe() 接收整型数组 fd[2]，其中，fd[0] 是管道的读端，fd[1] 是管道的写端；</li>
<li>如果子进程先得到运行，会阻塞在 read 调用，因为此时管道是空的；</li>
<li>父进程 write 数据到管道，此时子进程被唤醒继续运行，然后父进程阻塞在 read 调用，因为管道内容被子进程都取走了，是空的；</li>
<li>最后子进程写入管道，父进程 read 读到数据，并调用 wait() 等待子进程退出。</li>
</ul>
<h3 id="命名管道">命名管道</h3>
<p>命名管道在底层的实现跟匿名管道完全一致，区别只是命名管道会有一个全局可见的文件名以供别人 open 打开使用。</p>
<p>在程序中创建一个命名管道文件的方法有两种 API：</p>
<ul>
<li>mkfifo</li>
<li>mknod</li>
</ul>
<p>下面代码介绍了两种的具体实现</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">#include &lt;stdlib.h&gt;
</span></span><span class="line"><span class="cl">#include &lt;stdio.h&gt;
</span></span><span class="line"><span class="cl">#include &lt;unistd.h&gt;
</span></span><span class="line"><span class="cl">#include &lt;string.h&gt;
</span></span><span class="line"><span class="cl">#include &lt;sys/types.h&gt;
</span></span><span class="line"><span class="cl">#include &lt;sys/stat.h&gt;
</span></span><span class="line"><span class="cl">#include &lt;fcntl.h&gt;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">int main(){
</span></span><span class="line"><span class="cl">	int fd = open(&#34;./mypipe&#34;, O_WRONLY);
</span></span><span class="line"><span class="cl">    if (fd == -1) {
</span></span><span class="line"><span class="cl">        // method 1
</span></span><span class="line"><span class="cl">        if (fd = mkfifo(&#34;./mypipe&#34;, 0600) &lt; 0) {
</span></span><span class="line"><span class="cl">            perror(&#34;mkfifo()&#34;);
</span></span><span class="line"><span class="cl">            exit(1);
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        // method 2
</span></span><span class="line"><span class="cl">        //if (fd = mknod(&#34;./mypipe&#34;, 0600|S_IFIFO, 0) &lt; 0) {
</span></span><span class="line"><span class="cl">        //    perror(&#34;mknod()&#34;);
</span></span><span class="line"><span class="cl">        //    exit(1);
</span></span><span class="line"><span class="cl">        //}
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">    printf(&#34;fd %d\n&#34;, fd);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    /*
</span></span><span class="line"><span class="cl">    if (write(fd, &#34;hello&#34;, strlen(&#34;hello&#34;)) &lt; 0) {
</span></span><span class="line"><span class="cl">        perror(&#34;write()&#34;);
</span></span><span class="line"><span class="cl">        exit(1);
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    char buf[1024] = {0};
</span></span><span class="line"><span class="cl">    if (read(fd, buf, 1024) &lt; 0) {
</span></span><span class="line"><span class="cl">        perror(&#34;read()&#34;);
</span></span><span class="line"><span class="cl">        exit(1);
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">    */
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    return 0;
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>另外，也可以用命令行创建和测试命名管道。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">$ mkfifo myfifo
</span></span><span class="line"><span class="cl">$ ls -l myfifo
</span></span><span class="line"><span class="cl">prw-r--r--. 1 root root 0 1月  22 18:51 myfifo
</span></span></code></pre></td></tr></table>
</div>
</div><p>文件类型是 p，代表是命名管道文件。</p>
<p>打开一个终端 1，读管道数据会阻塞，因为此时管道还没有数据。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">$ cat myfifo
</span></span></code></pre></td></tr></table>
</div>
</div><p>打开另一个终端 2，向管道写入数据，此时终端 1 的 cat 进程将继续运行，并读取出管道的数据。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">// 终端 2
</span></span><span class="line"><span class="cl">$ echo &#34;hello world&#34; &gt; myfifo
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">// 终端 1
</span></span><span class="line"><span class="cl">$ cat myfifo
</span></span><span class="line"><span class="cl">hello world
</span></span></code></pre></td></tr></table>
</div>
</div><p><big><strong>小结</strong></big></p>
<ul>
<li>管道分为两种：匿名、命名；</li>
<li>匿名管道只能用来父子进程通信和同步；</li>
<li>命名管道可以跨进程通信和同步；</li>
<li>管道也是一种文件描述符，也可以被 select、poll、epoll 处理复用；</li>
<li>管道通信是半双工的，也就是只能在一端写，另一端读。相对应全双工通信的有 socketpair。</li>
</ul>
<p>最后，Linux 系统无论对于命名管道和匿名管道，底层都用的是同一种文件系统的操作行为，这种文件系统叫 pipefs。可以通过下面的命令查看：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">$ cat /proc/filesystems |grep pipefs
</span></span><span class="line"><span class="cl">nodev    pipefs
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="普通文件共享数据">普通文件共享数据</h2>
<p>下面的代码，尝试创建 100 个子进程，用文件存储要共享的数据，进行并发读写计数。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span><span class="lnt">70
</span><span class="lnt">71
</span><span class="lnt">72
</span><span class="lnt">73
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">#include &lt;unistd.h&gt;
</span></span><span class="line"><span class="cl">#include &lt;stdlib.h&gt;
</span></span><span class="line"><span class="cl">#include &lt;stdio.h&gt;
</span></span><span class="line"><span class="cl">#include &lt;errno.h&gt;
</span></span><span class="line"><span class="cl">#include &lt;fcntl.h&gt;
</span></span><span class="line"><span class="cl">#include &lt;string.h&gt;
</span></span><span class="line"><span class="cl">#include &lt;sys/file.h&gt;
</span></span><span class="line"><span class="cl">#include &lt;wait.h&gt;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">#define COUNT 100
</span></span><span class="line"><span class="cl">#define NUM 64
</span></span><span class="line"><span class="cl">#define FILEPATH &#34;/tmp/count&#34;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">int do_child(const char *path)
</span></span><span class="line"><span class="cl">{
</span></span><span class="line"><span class="cl">    /* 这个函数是每个子进程要做的事情
</span></span><span class="line"><span class="cl">    每个子进程都会按照这个步骤进行操作：
</span></span><span class="line"><span class="cl">    1. 打开FILEPATH路径的文件
</span></span><span class="line"><span class="cl">    2. 读出文件中的当前数字
</span></span><span class="line"><span class="cl">    3. 将字符串转成整数
</span></span><span class="line"><span class="cl">    4. 整数自增加1
</span></span><span class="line"><span class="cl">    5. 将证书转成字符串
</span></span><span class="line"><span class="cl">    6. lseek调整文件当前的偏移量到文件头
</span></span><span class="line"><span class="cl">    7. 将字符串写会文件
</span></span><span class="line"><span class="cl">    当多个进程同时执行这个过程的时候，就会出现racing：竞争条件，
</span></span><span class="line"><span class="cl">    多个进程可能同时从文件独到同一个数字，并且分别对同一个数字加1并写回，
</span></span><span class="line"><span class="cl">    导致多次写回的结果并不是我们最终想要的累积结果。 */
</span></span><span class="line"><span class="cl">    int fd;
</span></span><span class="line"><span class="cl">    int ret, count;
</span></span><span class="line"><span class="cl">    char buf[NUM];
</span></span><span class="line"><span class="cl">    fd = open(path, O_RDWR);
</span></span><span class="line"><span class="cl">    if (fd &lt; 0) {
</span></span><span class="line"><span class="cl">        perror(&#34;open()&#34;);
</span></span><span class="line"><span class="cl">        exit(1);
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">    /*    */
</span></span><span class="line"><span class="cl">    ret = read(fd, buf, NUM);
</span></span><span class="line"><span class="cl">    if (ret &lt; 0) {
</span></span><span class="line"><span class="cl">        perror(&#34;read()&#34;);
</span></span><span class="line"><span class="cl">        exit(1);
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">    buf[ret] = &#39;\0&#39;;
</span></span><span class="line"><span class="cl">    count = atoi(buf);
</span></span><span class="line"><span class="cl">    ++count;
</span></span><span class="line"><span class="cl">    sprintf(buf, &#34;%d&#34;, count);
</span></span><span class="line"><span class="cl">    lseek(fd, 0, SEEK_SET);
</span></span><span class="line"><span class="cl">    ret = write(fd, buf, strlen(buf));
</span></span><span class="line"><span class="cl">    /*    */
</span></span><span class="line"><span class="cl">    close(fd);
</span></span><span class="line"><span class="cl">    exit(0);
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">int main()
</span></span><span class="line"><span class="cl">{
</span></span><span class="line"><span class="cl">    pid_t pid;
</span></span><span class="line"><span class="cl">    int count;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    for (count=0;count&lt;COUNT;count++) {
</span></span><span class="line"><span class="cl">        pid = fork();
</span></span><span class="line"><span class="cl">        if (pid &lt; 0) {
</span></span><span class="line"><span class="cl">            perror(&#34;fork()&#34;);
</span></span><span class="line"><span class="cl">            exit(1);
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        if (pid == 0) {
</span></span><span class="line"><span class="cl">            do_child(FILEPATH);
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    for (count=0;count&lt;COUNT;count++) {
</span></span><span class="line"><span class="cl">        wait(NULL);
</span></span><span class="line"><span class="cl">    }    exit(0);
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>编译执行结果如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">$ gcc racing.c -o racing
</span></span><span class="line"><span class="cl">$ echo 0 &gt; /tmp/count
</span></span><span class="line"><span class="cl">$ ./racing 
</span></span><span class="line"><span class="cl">$ cat /tmp/count 
</span></span><span class="line"><span class="cl">71 
</span></span><span class="line"><span class="cl">$ echo 0 &gt; /tmp/count
</span></span><span class="line"><span class="cl">$ ./racing 
</span></span><span class="line"><span class="cl">$ cat /tmp/count 
</span></span><span class="line"><span class="cl">61
</span></span><span class="line"><span class="cl">$ echo 0 &gt; /tmp/count
</span></span><span class="line"><span class="cl">$ ./racing 
</span></span><span class="line"><span class="cl">$ cat /tmp/count 
</span></span><span class="line"><span class="cl">64
</span></span></code></pre></td></tr></table>
</div>
</div><p>可以看到，执行了几次的输出结果，都不是我们预期的 100。这是典型的竞态读写，由于我们没对临界区做访问限制，导致多个进程读取到的都是同一个数字。</p>
<p><strong>什么是临界资源？</strong></p>
<p>一次仅允许一个进程使用的资源。比如进程、线程之间共享的变量、数据就是。</p>
<p><strong>什么是临界区？</strong></p>
<p>每个进程中，访问临界资源的那段代码就是临界区。</p>
<p>为了保证临界资源的正确使用，可以将临界资源的访问分为4个部分</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">do {
</span></span><span class="line"><span class="cl">	entry section;    // 进入区（检查进程是否可以进入临界区）
</span></span><span class="line"><span class="cl">	critical section; // 临界区（访问临界资源）
</span></span><span class="line"><span class="cl">	exit section;     // 退出区（清除正在访问临界区的标志）
</span></span><span class="line"><span class="cl">	remainder section;// 剩余区（剩余代码）
</span></span><span class="line"><span class="cl">} while(true);
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="flock-api-解决竞态">flock API 解决竞态</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">#include &lt;stdlib.h&gt;
</span></span><span class="line"><span class="cl">#include &lt;stdio.h&gt;
</span></span><span class="line"><span class="cl">#include &lt;sys/types.h&gt;
</span></span><span class="line"><span class="cl">#include &lt;sys/stat.h&gt;
</span></span><span class="line"><span class="cl">#include &lt;fcntl.h&gt;
</span></span><span class="line"><span class="cl">#include &lt;unistd.h&gt;
</span></span><span class="line"><span class="cl">#include &lt;sys/file.h&gt;
</span></span><span class="line"><span class="cl">#include &lt;wait.h&gt;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">#define PATH &#34;/tmp/lock&#34;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">int main()
</span></span><span class="line"><span class="cl">{
</span></span><span class="line"><span class="cl">    int fd;
</span></span><span class="line"><span class="cl">    pid_t pid;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    fd = open(PATH, O_RDWR|O_CREAT|O_TRUNC|O_CLOEXEC, 0644);
</span></span><span class="line"><span class="cl">    if (fd &lt; 0) {
</span></span><span class="line"><span class="cl">        perror(&#34;open()&#34;);
</span></span><span class="line"><span class="cl">        exit(1);
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    // enable close-on-exec
</span></span><span class="line"><span class="cl">    //int flags = fcntl(fd, F_GETFD);
</span></span><span class="line"><span class="cl">    //flags |= FD_CLOEXEC;
</span></span><span class="line"><span class="cl">    //fcntl(fd, F_SETFD, flags);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    if (flock(fd, LOCK_EX) &lt; 0) {
</span></span><span class="line"><span class="cl">        perror(&#34;flock()&#34;);
</span></span><span class="line"><span class="cl">        exit(1);
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">    printf(&#34;%d: locked!\n&#34;, getpid());
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    pid = fork();
</span></span><span class="line"><span class="cl">    if (pid &lt; 0) {
</span></span><span class="line"><span class="cl">        perror(&#34;fork()&#34;);
</span></span><span class="line"><span class="cl">        exit(1);
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    if (pid == 0) {
</span></span><span class="line"><span class="cl">        //close(fd);
</span></span><span class="line"><span class="cl">        //fd = open(PATH, O_RDWR|O_CREAT|O_TRUNC, 0644);
</span></span><span class="line"><span class="cl">        //if (fd &lt; 0) {
</span></span><span class="line"><span class="cl">        //    perror(&#34;open()&#34;);
</span></span><span class="line"><span class="cl">        //    exit(1);
</span></span><span class="line"><span class="cl">        //}
</span></span><span class="line"><span class="cl">        if (flock(fd, LOCK_EX) &lt; 0) {
</span></span><span class="line"><span class="cl">            perror(&#34;flock()&#34;);
</span></span><span class="line"><span class="cl">            exit(1);
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">        printf(&#34;%d: locked!\n&#34;, getpid());
</span></span><span class="line"><span class="cl">        exit(0);
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">    wait(NULL);
</span></span><span class="line"><span class="cl">    unlink(PATH);
</span></span><span class="line"><span class="cl">    exit(0);
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>上面的代码流程是：</p>
<ol>
<li>打开 /tmp/lock 文件；</li>
<li>使用 flock 对其加互斥锁；</li>
<li>打印“PID：locked！”表示加锁成功；</li>
<li>fork 一个子进程，在子进程中也使用 flock 对 /tmp/lock 文件加互斥锁；</li>
<li>子进程也打印了“PID：locked！”表示加锁成功。如果加锁失败子进程会退出，不显示相关内容；</li>
<li>父进程回收子进程并退出。</li>
</ol>
<p>编译并运行它：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">$ gcc flock.c -o flock
</span></span><span class="line"><span class="cl">$ ./flock 
</span></span><span class="line"><span class="cl">12069: locked!
</span></span><span class="line"><span class="cl">12070: locked!
</span></span></code></pre></td></tr></table>
</div>
</div><p>父子进程都加锁成功了，这不符合我们使用锁的本意，为什么父子都能加锁成功呢？</p>
<p>因为子进程继承了父进程的锁文件描述符，而 flock() 对一个已持有锁的文件描述符，总是返回成功。（注意，使用 dup、dup2 API 复制锁文件描述符，也会出现这种情况）</p>
<p>解决方法有两种，也在上面的代码示例中体现了，就是：</p>
<ol>
<li>子进程中关闭锁文件描述符，重新打开它；</li>
<li>父进程打开锁文件时，开启 close-on-exec 标记，当创建子进程时，会自动关闭锁文件（不需要我们显式关闭）。</li>
</ol>
<h3 id="lockf-api-解决竞态">lockf API 解决竞态</h3>
<p>lockf 可以实现和 flock 一样的功能，而且没有父子进程间同时加锁成功的现象，代码如下。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">#include &lt;stdlib.h&gt;
</span></span><span class="line"><span class="cl">#include &lt;stdio.h&gt;
</span></span><span class="line"><span class="cl">#include &lt;sys/types.h&gt;
</span></span><span class="line"><span class="cl">#include &lt;sys/stat.h&gt;
</span></span><span class="line"><span class="cl">#include &lt;fcntl.h&gt;
</span></span><span class="line"><span class="cl">#include &lt;unistd.h&gt;
</span></span><span class="line"><span class="cl">#include &lt;sys/file.h&gt;
</span></span><span class="line"><span class="cl">#include &lt;wait.h&gt;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">#define PATH &#34;/tmp/lock&#34;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">int main()
</span></span><span class="line"><span class="cl">{
</span></span><span class="line"><span class="cl">    int fd;
</span></span><span class="line"><span class="cl">    pid_t pid;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    fd = open(PATH, O_RDWR|O_CREAT|O_TRUNC, 0644);
</span></span><span class="line"><span class="cl">    if (fd &lt; 0) {
</span></span><span class="line"><span class="cl">        perror(&#34;open()&#34;);
</span></span><span class="line"><span class="cl">        exit(1);
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    if (lockf(fd, F_LOCK, 0) &lt; 0) {
</span></span><span class="line"><span class="cl">        perror(&#34;lockf()&#34;);
</span></span><span class="line"><span class="cl">        exit(1);
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">    printf(&#34;%d: locked!\n&#34;, getpid());
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    pid = fork();
</span></span><span class="line"><span class="cl">    if (pid &lt; 0) {
</span></span><span class="line"><span class="cl">        perror(&#34;fork()&#34;);
</span></span><span class="line"><span class="cl">        exit(1);
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    if (pid == 0) {
</span></span><span class="line"><span class="cl">        if (lockf(fd, F_LOCK, 0) &lt; 0) {
</span></span><span class="line"><span class="cl">            perror(&#34;lockf()&#34;);
</span></span><span class="line"><span class="cl">            exit(1);
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">        printf(&#34;%d: locked!\n&#34;, getpid());
</span></span><span class="line"><span class="cl">        exit(0);
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">    wait(NULL);
</span></span><span class="line"><span class="cl">    unlink(PATH);    
</span></span><span class="line"><span class="cl">    exit(0);
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>编译执行结果：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">$ ./a.out
</span></span><span class="line"><span class="cl">12146: locked!
</span></span></code></pre></td></tr></table>
</div>
</div><p>可以看到，在子进程中不用 open 重新打开文件的情况下，进程执行被阻塞在子进程 lockf 加锁的操作上了。其实 lockf 底层也是通过调用 fcntl 实现的，可以用 strace -f ./a.out 查看系统调用。</p>
<h3 id="flock-命令实现程序只运行一次">flock 命令实现程序只运行一次</h3>
<p>当我们做计划任务，定时运行某个程序时，会通过 crontab 加程序或者脚本的组合形式实现，类似下面：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">*/1 * * * * sh /home/calc_user_pvuv.sh
</span></span></code></pre></td></tr></table>
</div>
</div><p>考虑一种场景，calc_user_pvuv.sh 脚本执行时长超过 1 分钟，而我们又不想让程序并发执行，因为并发可能会出现不可预期的临界错误。那么我们就可以通过 flock 命令解决：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">*/1 * * * * flock -x /tmp/lock-file -c &#34;sh /home/calc_user_pvuv.sh&#34;
</span></span></code></pre></td></tr></table>
</div>
</div><p>执行 flock 命令等同于：</p>
<ul>
<li>open(&quot;/tmp/lock-file&quot;, O_RDONLY|O_CREAT|O_NOCTTY, 0666) = 3</li>
<li>flock(3, LOCK_EX)</li>
<li>fork()</li>
<li>execve(&quot;/bin/bash&quot;, [&quot;/bin/bash&quot;, &ldquo;-c&rdquo;, &ldquo;echo hello&rdquo;])</li>
<li>&hellip;</li>
</ul>
<p>所以，flock 命令的底层就是调用 flock API 锁住 /tmp/lock-file 文件，N 个进程里只能有一个进程拿到锁文件的控制权限，也就限制了程序的并发运行。</p>
<p><big><strong>小结</strong></big></p>
<ol>
<li>文件共享数据会产生竞争，如果是不同进程间通信需要加更大粒度的文件锁；</li>
<li>文件锁有两种实现，一种是 flock，另一种是 lockf，lockf 是对 fcntl 的封装；</li>
<li>linux 系统命令 flock 可以实现在并发执行下，当前时刻只有一个进程运行。进程运行完毕后，再运行另外一个被阻塞的进程。</li>
</ol>
<h2 id="共享内存">共享内存</h2>
<h3 id="mmap-共享内存">mmap 共享内存</h3>
<p>简单说，mmap API 有两种用途，</p>
<ol>
<li>把文件内容映射到 page cache，并让 page cache 和进程的虚拟地址空间绑定；</li>
<li>父子进程间共享内存，注意不要填写 MAP_PRIVATE 参数，否则父子进程间将触发写时复制，也达不到共享内存的目的了。</li>
</ol>
<p>一个映射文件的例子。注意，调用 mmap API 时一般情况下都是填写 MAP_SHARED。如果填写的是 MAP_PRIVATE，修改将触发写时复制机制，修改将不会写回文件，修改的只是内存中的副本。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">#include &lt;stdio.h&gt;
</span></span><span class="line"><span class="cl">#include &lt;unistd.h&gt;
</span></span><span class="line"><span class="cl">#include &lt;stdlib.h&gt;
</span></span><span class="line"><span class="cl">#include &lt;sys/mman.h&gt;
</span></span><span class="line"><span class="cl">#include &lt;fcntl.h&gt;
</span></span><span class="line"><span class="cl">int main() {
</span></span><span class="line"><span class="cl">	int fr = open(&#34;a.txt&#34;,O_RDWR);
</span></span><span class="line"><span class="cl">	if(fr&lt;0) {
</span></span><span class="line"><span class="cl">        exit(0);
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">    char *buf = (char*)mmap(NULL, 100, PROT_READ|PROT_WRITE, MAP_SHARED, fr, 0); 
</span></span><span class="line"><span class="cl">    int i;
</span></span><span class="line"><span class="cl">    while(buf[i] != &#39;\0&#39;) {
</span></span><span class="line"><span class="cl">        printf(&#34;%c\n&#34;,buf[i++]);
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">	munmap(buf, 100);
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>再来一个父子进程共享内存的示例，创建 100 个子进程同时读写共享内存来看看竞争条件 racing 的情况。参数 MAP_ANONYMOUS 表示只做内存映射，而不做文件映射，将忽略 fd 和 offset 两个参数。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">#include &lt;unistd.h&gt;
</span></span><span class="line"><span class="cl">#include &lt;stdlib.h&gt;
</span></span><span class="line"><span class="cl">#include &lt;stdio.h&gt;
</span></span><span class="line"><span class="cl">#include &lt;errno.h&gt;
</span></span><span class="line"><span class="cl">#include &lt;fcntl.h&gt;
</span></span><span class="line"><span class="cl">#include &lt;string.h&gt;
</span></span><span class="line"><span class="cl">#include &lt;sys/file.h&gt;
</span></span><span class="line"><span class="cl">#include &lt;wait.h&gt;
</span></span><span class="line"><span class="cl">#include &lt;sys/mman.h&gt;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">#define COUNT 100
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">int do_child(int *count)
</span></span><span class="line"><span class="cl">{
</span></span><span class="line"><span class="cl">    int interval;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    /* critical section */
</span></span><span class="line"><span class="cl">    interval = *count;
</span></span><span class="line"><span class="cl">    interval++;
</span></span><span class="line"><span class="cl">    usleep(1);
</span></span><span class="line"><span class="cl">    *count = interval;
</span></span><span class="line"><span class="cl">    /* critical section */
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    exit(0);
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">int main()
</span></span><span class="line"><span class="cl">{
</span></span><span class="line"><span class="cl">    pid_t pid;
</span></span><span class="line"><span class="cl">    int count;
</span></span><span class="line"><span class="cl">    int *shm_p;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    shm_p = (int *)mmap(NULL, sizeof(int), PROT_WRITE|PROT_READ, MAP_SHARED|MAP_ANONYMOUS, -1, 0);
</span></span><span class="line"><span class="cl">    if (MAP_FAILED == shm_p) {
</span></span><span class="line"><span class="cl">        perror(&#34;mmap()&#34;);
</span></span><span class="line"><span class="cl">        exit(1);
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    *shm_p = 0;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    for (count=0;count&lt;COUNT;count++) {
</span></span><span class="line"><span class="cl">        pid = fork();
</span></span><span class="line"><span class="cl">        if (pid &lt; 0) {
</span></span><span class="line"><span class="cl">            perror(&#34;fork()&#34;);
</span></span><span class="line"><span class="cl">            exit(1);
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        if (pid == 0) {
</span></span><span class="line"><span class="cl">            do_child(shm_p);
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    for (count=0;count&lt;COUNT;count++) {
</span></span><span class="line"><span class="cl">        wait(NULL);
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    printf(&#34;shm_p: %d\n&#34;, *shm_p);
</span></span><span class="line"><span class="cl">    munmap(shm_p, sizeof(int));
</span></span><span class="line"><span class="cl">    exit(0);
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>这个例子中，我们在子进程中为了延长临界区（critical section）处理的时间，使用了一个中间变量进行数值交换，并且还用 usleep 加强了一下 racing 的效果，最后执行结果：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">$ ./racing_mmap 
</span></span><span class="line"><span class="cl">shm_p: 20
</span></span><span class="line"><span class="cl">$ ./racing_mmap 
</span></span><span class="line"><span class="cl">shm_p: 17
</span></span><span class="line"><span class="cl">$ ./racing_mmap 
</span></span><span class="line"><span class="cl">shm_p: 14
</span></span><span class="line"><span class="cl">$ ./racing_mmap 
</span></span><span class="line"><span class="cl">shm_p: 15
</span></span></code></pre></td></tr></table>
</div>
</div><p>结果并不是我们预期的 100，所以为了限制只有一个进程可以进入临界区，我们可以通过使用文件锁、信号量来实现；</p>
<p>另外，mmap 方式的匿名共享内存只能在通过 fork 产生的父子进程间通信，其它进程无法得到共享内存段的地址。</p>
<h3 id="xsi-共享内存">XSI 共享内存</h3>
<p>为了满足多个无关进程之间共享内存的需求，Linux 提供了 XSI 共享内存。实际上在 Linux 底层跟 mmap 没有什么本质不同，只是在使用方法上有所区别。代码如下。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">  1
</span><span class="lnt">  2
</span><span class="lnt">  3
</span><span class="lnt">  4
</span><span class="lnt">  5
</span><span class="lnt">  6
</span><span class="lnt">  7
</span><span class="lnt">  8
</span><span class="lnt">  9
</span><span class="lnt"> 10
</span><span class="lnt"> 11
</span><span class="lnt"> 12
</span><span class="lnt"> 13
</span><span class="lnt"> 14
</span><span class="lnt"> 15
</span><span class="lnt"> 16
</span><span class="lnt"> 17
</span><span class="lnt"> 18
</span><span class="lnt"> 19
</span><span class="lnt"> 20
</span><span class="lnt"> 21
</span><span class="lnt"> 22
</span><span class="lnt"> 23
</span><span class="lnt"> 24
</span><span class="lnt"> 25
</span><span class="lnt"> 26
</span><span class="lnt"> 27
</span><span class="lnt"> 28
</span><span class="lnt"> 29
</span><span class="lnt"> 30
</span><span class="lnt"> 31
</span><span class="lnt"> 32
</span><span class="lnt"> 33
</span><span class="lnt"> 34
</span><span class="lnt"> 35
</span><span class="lnt"> 36
</span><span class="lnt"> 37
</span><span class="lnt"> 38
</span><span class="lnt"> 39
</span><span class="lnt"> 40
</span><span class="lnt"> 41
</span><span class="lnt"> 42
</span><span class="lnt"> 43
</span><span class="lnt"> 44
</span><span class="lnt"> 45
</span><span class="lnt"> 46
</span><span class="lnt"> 47
</span><span class="lnt"> 48
</span><span class="lnt"> 49
</span><span class="lnt"> 50
</span><span class="lnt"> 51
</span><span class="lnt"> 52
</span><span class="lnt"> 53
</span><span class="lnt"> 54
</span><span class="lnt"> 55
</span><span class="lnt"> 56
</span><span class="lnt"> 57
</span><span class="lnt"> 58
</span><span class="lnt"> 59
</span><span class="lnt"> 60
</span><span class="lnt"> 61
</span><span class="lnt"> 62
</span><span class="lnt"> 63
</span><span class="lnt"> 64
</span><span class="lnt"> 65
</span><span class="lnt"> 66
</span><span class="lnt"> 67
</span><span class="lnt"> 68
</span><span class="lnt"> 69
</span><span class="lnt"> 70
</span><span class="lnt"> 71
</span><span class="lnt"> 72
</span><span class="lnt"> 73
</span><span class="lnt"> 74
</span><span class="lnt"> 75
</span><span class="lnt"> 76
</span><span class="lnt"> 77
</span><span class="lnt"> 78
</span><span class="lnt"> 79
</span><span class="lnt"> 80
</span><span class="lnt"> 81
</span><span class="lnt"> 82
</span><span class="lnt"> 83
</span><span class="lnt"> 84
</span><span class="lnt"> 85
</span><span class="lnt"> 86
</span><span class="lnt"> 87
</span><span class="lnt"> 88
</span><span class="lnt"> 89
</span><span class="lnt"> 90
</span><span class="lnt"> 91
</span><span class="lnt"> 92
</span><span class="lnt"> 93
</span><span class="lnt"> 94
</span><span class="lnt"> 95
</span><span class="lnt"> 96
</span><span class="lnt"> 97
</span><span class="lnt"> 98
</span><span class="lnt"> 99
</span><span class="lnt">100
</span><span class="lnt">101
</span><span class="lnt">102
</span><span class="lnt">103
</span><span class="lnt">104
</span><span class="lnt">105
</span><span class="lnt">106
</span><span class="lnt">107
</span><span class="lnt">108
</span><span class="lnt">109
</span><span class="lnt">110
</span><span class="lnt">111
</span><span class="lnt">112
</span><span class="lnt">113
</span><span class="lnt">114
</span><span class="lnt">115
</span><span class="lnt">116
</span><span class="lnt">117
</span><span class="lnt">118
</span><span class="lnt">119
</span><span class="lnt">120
</span><span class="lnt">121
</span><span class="lnt">122
</span><span class="lnt">123
</span><span class="lnt">124
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">#include &lt;unistd.h&gt;
</span></span><span class="line"><span class="cl">#include &lt;stdlib.h&gt;
</span></span><span class="line"><span class="cl">#include &lt;stdio.h&gt;
</span></span><span class="line"><span class="cl">#include &lt;errno.h&gt;
</span></span><span class="line"><span class="cl">#include &lt;fcntl.h&gt;
</span></span><span class="line"><span class="cl">#include &lt;string.h&gt;
</span></span><span class="line"><span class="cl">#include &lt;sys/file.h&gt;
</span></span><span class="line"><span class="cl">#include &lt;wait.h&gt;
</span></span><span class="line"><span class="cl">#include &lt;sys/mman.h&gt;
</span></span><span class="line"><span class="cl">#include &lt;sys/ipc.h&gt;
</span></span><span class="line"><span class="cl">#include &lt;sys/shm.h&gt;
</span></span><span class="line"><span class="cl">#include &lt;sys/types.h&gt;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">#define COUNT 100
</span></span><span class="line"><span class="cl">#define PATHNAME &#34;/etc/passwd&#34;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">int do_child(int proj_id)
</span></span><span class="line"><span class="cl">{
</span></span><span class="line"><span class="cl">    int interval;
</span></span><span class="line"><span class="cl">    int *shm_p, shm_id;
</span></span><span class="line"><span class="cl">    key_t shm_key;
</span></span><span class="line"><span class="cl">    /* 使用ftok产生shmkey */
</span></span><span class="line"><span class="cl">    if ((shm_key = ftok(PATHNAME, proj_id)) == -1) {
</span></span><span class="line"><span class="cl">        perror(&#34;ftok()&#34;);
</span></span><span class="line"><span class="cl">        exit(1);
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">    /* 在子进程中使用shmget取到已经在父进程中创建好的共享内存id，注意shmget的第三个参数的使用。 */
</span></span><span class="line"><span class="cl">    shm_id = shmget(shm_key, sizeof(int), 0);
</span></span><span class="line"><span class="cl">    if (shm_id &lt; 0) {
</span></span><span class="line"><span class="cl">        perror(&#34;shmget()&#34;);
</span></span><span class="line"><span class="cl">        exit(1);
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    /* 使用shmat将相关共享内存段映射到本进程的内存地址。 */
</span></span><span class="line"><span class="cl">    shm_p = (int *)shmat(shm_id, NULL, 0);
</span></span><span class="line"><span class="cl">    if ((void *)shm_p == (void *)-1) {
</span></span><span class="line"><span class="cl">        perror(&#34;shmat()&#34;);
</span></span><span class="line"><span class="cl">        exit(1);
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    /* critical section */
</span></span><span class="line"><span class="cl">    interval = *shm_p;
</span></span><span class="line"><span class="cl">    interval++;
</span></span><span class="line"><span class="cl">    usleep(1);
</span></span><span class="line"><span class="cl">    *shm_p = interval;
</span></span><span class="line"><span class="cl">    /* critical section */
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    /* 使用shmdt解除本进程内对共享内存的地址映射，本操作不会删除共享内存。 */
</span></span><span class="line"><span class="cl">    if (shmdt(shm_p) &lt; 0) {
</span></span><span class="line"><span class="cl">        perror(&#34;shmdt()&#34;);
</span></span><span class="line"><span class="cl">        exit(1);
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    exit(0);
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">int main()
</span></span><span class="line"><span class="cl">{
</span></span><span class="line"><span class="cl">    pid_t pid;
</span></span><span class="line"><span class="cl">    int count;
</span></span><span class="line"><span class="cl">    int *shm_p;
</span></span><span class="line"><span class="cl">    int shm_id, proj_id;
</span></span><span class="line"><span class="cl">    key_t shm_key;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    proj_id = 1234;
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    /* 使用约定好的文件路径和proj_id产生shm_key。 */
</span></span><span class="line"><span class="cl">    if ((shm_key = ftok(PATHNAME, proj_id)) == -1) {
</span></span><span class="line"><span class="cl">        perror(&#34;ftok()&#34;);
</span></span><span class="line"><span class="cl">        exit(1);
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    /* 使用shm_key创建一个共享内存，如果系统中已经存在此共享内存则报错退出，创建出来的共享内存权限为0600。 */
</span></span><span class="line"><span class="cl">    shm_id = shmget(shm_key, sizeof(int), IPC_CREAT|IPC_EXCL|0600);
</span></span><span class="line"><span class="cl">    if (shm_id &lt; 0) {
</span></span><span class="line"><span class="cl">        perror(&#34;shmget()&#34;);
</span></span><span class="line"><span class="cl">        exit(1);
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    /* 将创建好的共享内存映射进父进程的地址以便访问。 */
</span></span><span class="line"><span class="cl">    shm_p = (int *)shmat(shm_id, NULL, 0);
</span></span><span class="line"><span class="cl">    if ((void *)shm_p == (void *)-1) {
</span></span><span class="line"><span class="cl">        perror(&#34;shmat()&#34;);
</span></span><span class="line"><span class="cl">        exit(1);
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    /* 共享内存赋值为0。 */
</span></span><span class="line"><span class="cl">    *shm_p = 0;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    /*  打开100个子进程并发读写共享内存。 */
</span></span><span class="line"><span class="cl">    for (count=0;count&lt;COUNT;count++) {
</span></span><span class="line"><span class="cl">        pid = fork();
</span></span><span class="line"><span class="cl">        if (pid &lt; 0) {
</span></span><span class="line"><span class="cl">            perror(&#34;fork()&#34;);
</span></span><span class="line"><span class="cl">            exit(1);
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        if (pid == 0) {
</span></span><span class="line"><span class="cl">            do_child(proj_id);
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    /* 等待所有子进程执行完毕。 */
</span></span><span class="line"><span class="cl">    for (count=0;count&lt;COUNT;count++) {
</span></span><span class="line"><span class="cl">        wait(NULL);
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    /* 显示当前共享内存的值。 */
</span></span><span class="line"><span class="cl">    printf(&#34;shm_p: %d\n&#34;, *shm_p);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    /* 解除共享内存地质映射。 */
</span></span><span class="line"><span class="cl">    if (shmdt(shm_p) &lt; 0) {
</span></span><span class="line"><span class="cl">        perror(&#34;shmdt()&#34;);
</span></span><span class="line"><span class="cl">        exit(1);
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    /* 删除共享内存。 */
</span></span><span class="line"><span class="cl">    if (shmctl(shm_id, IPC_RMID, NULL) &lt; 0) {
</span></span><span class="line"><span class="cl">        perror(&#34;shmctl()&#34;);
</span></span><span class="line"><span class="cl">        exit(1);
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    exit(0);
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p><strong>XSI 共享内存的通信共有 6 个步骤：</strong></p>
<ol>
<li>创建唯一 key：shm_key = ftok(PATHNAME, proj_id)；</li>
<li>获取共享内存 id：shm_id = shmget(shm_key, sizeof(int), IPC_CREAT|IPC_EXCL|0600)。已创建的用 shmget(shm_key, sizeof(int), 0) 来获取；</li>
<li>映射到进程虚拟地址空间：shm_p = shmat(shm_id, NULL, 0)；</li>
<li>对 shm_p 指针进行读写；</li>
<li>解除共享内存的地址空间映射：shmdt(shm_p)；</li>
<li>删除共享内存：shmctl(shm_id, IPC_RMID, NULL)。</li>
</ol>
<p><strong>编译执行结果如下：</strong></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">$ gcc racing_xsi_shm.c -o racing_xsi_shm -lrt$ ./racing_xsi_shm 
</span></span><span class="line"><span class="cl">shm_p: 27
</span></span><span class="line"><span class="cl">$ ./racing_xsi_shm 
</span></span><span class="line"><span class="cl">shm_p: 22
</span></span><span class="line"><span class="cl">$ ./racing_xsi_shm 
</span></span><span class="line"><span class="cl">shm_p: 21
</span></span><span class="line"><span class="cl">$ ./racing_xsi_shm 
</span></span><span class="line"><span class="cl">shm_p: 20
</span></span></code></pre></td></tr></table>
</div>
</div><p>XSI 共享内存的系统相关限制如下：</p>
<ul>
<li><strong>/proc/sys/kernel/shmall</strong> 限制系统用在共享内存上的内存总页数。注意是页数，单位为 4k</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">$ cat /proc/sys/kernel/shmall
</span></span><span class="line"><span class="cl">18446744073692774399
</span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li><strong>/proc/sys/kernel/shmmax</strong> 限制一个共享内存段的最大长度，字节为单位</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">cat /proc/sys/kernel/shmmax
</span></span><span class="line"><span class="cl">18446744073692774399
</span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li><strong>/proc/sys/kernel/shmmni</strong> 限制整个系统可创建的最大的共享内存段个数</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">$ cat /proc/sys/kernel/shmmni
</span></span><span class="line"><span class="cl">4096
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="posix-共享内存">POSIX 共享内存</h3>
<p>Linux 提供的 POSIX 共享内存，实际上就是在 /dev/shm 目录下创建一个文件，并将其 mmap 之后映射其内存地址即可。再具体一点说，</p>
<ol>
<li>shm_open 参数的路径默认是放在 /dev/shm 目录下。这是 shm_open 已经封装好的，保证了文件一定会使用 tmpfs。</li>
<li>设置“共享内存”的大小是使用 ftruncate API。其实就是更改文件的长度。</li>
<li>还要使用 mmap API，把 shm_open 返回的文件描述符内容映射进内存。</li>
<li>shm_unlink 实际上就是 unlink 系统调用的封装。如果不做 unlink 操作，那么文件会一直存在于 /dev/shm 目录下，以供其它进程使用。</li>
<li>关闭共享内存描述符直接使用close。</li>
</ol>
<p>代码如下。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span><span class="lnt">70
</span><span class="lnt">71
</span><span class="lnt">72
</span><span class="lnt">73
</span><span class="lnt">74
</span><span class="lnt">75
</span><span class="lnt">76
</span><span class="lnt">77
</span><span class="lnt">78
</span><span class="lnt">79
</span><span class="lnt">80
</span><span class="lnt">81
</span><span class="lnt">82
</span><span class="lnt">83
</span><span class="lnt">84
</span><span class="lnt">85
</span><span class="lnt">86
</span><span class="lnt">87
</span><span class="lnt">88
</span><span class="lnt">89
</span><span class="lnt">90
</span><span class="lnt">91
</span><span class="lnt">92
</span><span class="lnt">93
</span><span class="lnt">94
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">#include &lt;unistd.h&gt;
</span></span><span class="line"><span class="cl">#include &lt;stdlib.h&gt;
</span></span><span class="line"><span class="cl">#include &lt;stdio.h&gt;
</span></span><span class="line"><span class="cl">#include &lt;errno.h&gt;
</span></span><span class="line"><span class="cl">#include &lt;fcntl.h&gt;
</span></span><span class="line"><span class="cl">#include &lt;string.h&gt;
</span></span><span class="line"><span class="cl">#include &lt;sys/file.h&gt;
</span></span><span class="line"><span class="cl">#include &lt;wait.h&gt;
</span></span><span class="line"><span class="cl">#include &lt;sys/mman.h&gt;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">#define COUNT 100
</span></span><span class="line"><span class="cl">#define SHMPATH &#34;shm&#34;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">int do_child(char * shmpath)
</span></span><span class="line"><span class="cl">{
</span></span><span class="line"><span class="cl">    int interval, shmfd, ret;
</span></span><span class="line"><span class="cl">    int *shm_p;
</span></span><span class="line"><span class="cl">    /* 使用shm_open访问一个已经创建的POSIX共享内存 */
</span></span><span class="line"><span class="cl">    shmfd = shm_open(shmpath, O_RDWR, 0600);
</span></span><span class="line"><span class="cl">    if (shmfd &lt; 0) {
</span></span><span class="line"><span class="cl">        perror(&#34;shm_open()&#34;);
</span></span><span class="line"><span class="cl">        exit(1);
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    /* 使用mmap将对应的tmpfs文件映射到本进程内存 */
</span></span><span class="line"><span class="cl">    shm_p = (int *)mmap(NULL, sizeof(int), PROT_WRITE|PROT_READ, MAP_SHARED, shmfd, 0);
</span></span><span class="line"><span class="cl">    if (MAP_FAILED == shm_p) {
</span></span><span class="line"><span class="cl">        perror(&#34;mmap()&#34;);
</span></span><span class="line"><span class="cl">        exit(1);
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">    /* critical section */
</span></span><span class="line"><span class="cl">    interval = *shm_p;
</span></span><span class="line"><span class="cl">    interval++;
</span></span><span class="line"><span class="cl">    usleep(1);
</span></span><span class="line"><span class="cl">    *shm_p = interval;
</span></span><span class="line"><span class="cl">    /* critical section */
</span></span><span class="line"><span class="cl">    munmap(shm_p, sizeof(int));
</span></span><span class="line"><span class="cl">    close(shmfd);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    exit(0);
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">int main()
</span></span><span class="line"><span class="cl">{
</span></span><span class="line"><span class="cl">    pid_t pid;
</span></span><span class="line"><span class="cl">    int count, shmfd, ret;
</span></span><span class="line"><span class="cl">    int *shm_p;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    /* 创建一个POSIX共享内存 */
</span></span><span class="line"><span class="cl">    shmfd = shm_open(SHMPATH, O_RDWR|O_CREAT|O_TRUNC, 0600);
</span></span><span class="line"><span class="cl">    if (shmfd &lt; 0) {
</span></span><span class="line"><span class="cl">        perror(&#34;shm_open()&#34;);
</span></span><span class="line"><span class="cl">        exit(1);
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    /* 使用ftruncate设置共享内存段大小 */
</span></span><span class="line"><span class="cl">    ret = ftruncate(shmfd, sizeof(int));
</span></span><span class="line"><span class="cl">    if (ret &lt; 0) {
</span></span><span class="line"><span class="cl">        perror(&#34;ftruncate()&#34;);
</span></span><span class="line"><span class="cl">        exit(1);
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    /* 使用mmap将对应的tmpfs文件映射到本进程内存 */
</span></span><span class="line"><span class="cl">    shm_p = (int *)mmap(NULL, sizeof(int), PROT_WRITE|PROT_READ, MAP_SHARED, shmfd, 0);
</span></span><span class="line"><span class="cl">    if (MAP_FAILED == shm_p) {
</span></span><span class="line"><span class="cl">        perror(&#34;mmap()&#34;);
</span></span><span class="line"><span class="cl">        exit(1);
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    *shm_p = 0;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    for (count=0;count&lt;COUNT;count++) {
</span></span><span class="line"><span class="cl">        pid = fork();
</span></span><span class="line"><span class="cl">        if (pid &lt; 0) {
</span></span><span class="line"><span class="cl">            perror(&#34;fork()&#34;);
</span></span><span class="line"><span class="cl">            exit(1);
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        if (pid == 0) {
</span></span><span class="line"><span class="cl">            do_child(SHMPATH);
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    for (count=0;count&lt;COUNT;count++) {
</span></span><span class="line"><span class="cl">        wait(NULL);
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    printf(&#34;shm_p: %d\n&#34;, *shm_p);
</span></span><span class="line"><span class="cl">    munmap(shm_p, sizeof(int));
</span></span><span class="line"><span class="cl">    close(shmfd);
</span></span><span class="line"><span class="cl">    //sleep(3000);
</span></span><span class="line"><span class="cl">    shm_unlink(SHMPATH);
</span></span><span class="line"><span class="cl">    exit(0);
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>编译执行这个程序需要 rt 库，如下命令进行编译。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">$ gcc -o racing_posix_shm -lrt racing_posix_shm.c
</span></span></code></pre></td></tr></table>
</div>
</div><p><big><strong>小结</strong></big></p>
<ol>
<li>Linux 有三种共享内存的实现：mmap、XSI、POSIX；</li>
<li>XSI 方式申请的内存可以通过 ipcs 命令看到，如果程序里不主动删除，就会一直存在操作系统当中，也可以通过 ipcrm 命令将其删除；</li>
<li>POSIX 共享内存就是对 open() 和 mmap() 的封装，文件默认保存在 /dev/shm/ 目录下面；</li>
<li>POSIX 共享内存和 XSI 的区别就是：POSIX 使用文件名作为全局标识，XSI 使用 key；</li>
<li>三种共享内存的底层实现方式都一样，内存占用统计也都一样；</li>
</ol>
<h2 id="消息队列">消息队列</h2>
<p>Linux系统给我们提供了一种可以发送格式化数据流的通信手段，这就是消息队列。</p>
<p>相同的工作如果使用共享内存，除了需要自己手工构造一个可能不够高效的队列外，还需要我们处理竞争条件和临界区代码，极不方便。</p>
<h3 id="xsi-消息队列">XSI 消息队列</h3>
<p><strong>msgsnd API 发送消息</strong></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">#include &lt;sys/types.h&gt;
</span></span><span class="line"><span class="cl">#include &lt;sys/ipc.h&gt;
</span></span><span class="line"><span class="cl">#include &lt;sys/msg.h&gt;
</span></span><span class="line"><span class="cl">#include &lt;stdlib.h&gt;
</span></span><span class="line"><span class="cl">#include &lt;stdio.h&gt;
</span></span><span class="line"><span class="cl">#include &lt;string.h&gt;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">#define FILEPATH &#34;/etc/passwd&#34;
</span></span><span class="line"><span class="cl">#define PROJID 1234
</span></span><span class="line"><span class="cl">#define MSG &#34;hello world!&#34;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">struct msgbuf {
</span></span><span class="line"><span class="cl">    long mtype;
</span></span><span class="line"><span class="cl">    char mtext[BUFSIZ];
</span></span><span class="line"><span class="cl">};
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">int main()
</span></span><span class="line"><span class="cl">{
</span></span><span class="line"><span class="cl">    int msgid;
</span></span><span class="line"><span class="cl">    key_t key;
</span></span><span class="line"><span class="cl">    struct msgbuf buf;
</span></span><span class="line"><span class="cl">    struct msqid_ds msg_buf;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    key = ftok(FILEPATH, PROJID);
</span></span><span class="line"><span class="cl">    if (key == -1) {
</span></span><span class="line"><span class="cl">        perror(&#34;ftok()&#34;);
</span></span><span class="line"><span class="cl">        exit(1);
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    msgid = msgget(key, IPC_CREAT|IPC_EXCL|0600);
</span></span><span class="line"><span class="cl">    if (msgid == -1) { // 如果已经存在
</span></span><span class="line"><span class="cl">        msgid = msgget(key, 0); // 使用msgget访问一个已经存在的消息队列时，msgflag指定为0即可
</span></span><span class="line"><span class="cl">        if (msgid == -1) {
</span></span><span class="line"><span class="cl">            perror(&#34;msgget()&#34;);
</span></span><span class="line"><span class="cl">            exit(1);
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    if (msgctl(msgid, IPC_STAT, &amp;msg_buf) == -1) {
</span></span><span class="line"><span class="cl">        perror(&#34;msgctl()&#34;);
</span></span><span class="line"><span class="cl">        exit(1);
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    printf(&#34;msg key: 0x%x\n&#34;, key);
</span></span><span class="line"><span class="cl">    printf(&#34;msgid: %d\n&#34;, msgid);
</span></span><span class="line"><span class="cl">    printf(&#34;msg_perm.uid: %d\n&#34;, msg_buf.msg_perm.uid);
</span></span><span class="line"><span class="cl">    printf(&#34;msg_perm.gid: %d\n&#34;, msg_buf.msg_perm.gid);
</span></span><span class="line"><span class="cl">    printf(&#34;msg_stime: %d\n&#34;, msg_buf.msg_stime);
</span></span><span class="line"><span class="cl">    printf(&#34;msg_rtime: %d\n&#34;, msg_buf.msg_rtime);
</span></span><span class="line"><span class="cl">	printf(&#34;msg_qnum: %d\n&#34;, msg_buf.msg_qnum);
</span></span><span class="line"><span class="cl">    printf(&#34;msg_qbytes: %d\n&#34;, msg_buf.msg_qbytes);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    buf.mtype = 1;
</span></span><span class="line"><span class="cl">    strncpy(buf.mtext, MSG, strlen(MSG));
</span></span><span class="line"><span class="cl">    if (msgsnd(msgid, &amp;buf, strlen(buf.mtext), 0) == -1) {
</span></span><span class="line"><span class="cl">        perror(&#34;msgsnd()&#34;);
</span></span><span class="line"><span class="cl">        exit(1);
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>我们编译执行，并通过 ipcs -q 命令看下当前消息数量和大小：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">$ gcc msg_send.c -o ./send
</span></span><span class="line"><span class="cl">$ ipcs -q
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">------ Message Queues --------
</span></span><span class="line"><span class="cl">key        msqid      owner      perms      used-bytes   messages
</span></span><span class="line"><span class="cl">0xd20097a6 4          root       600        0            0
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">$ ./send
</span></span><span class="line"><span class="cl">$ ipcs -q
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">------ Message Queues --------
</span></span><span class="line"><span class="cl">key        msqid      owner      perms      used-bytes   messages
</span></span><span class="line"><span class="cl">0xd20097a6 4          root       600        12           1
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">$ ./send
</span></span><span class="line"><span class="cl">$ ./send
</span></span><span class="line"><span class="cl">$ ipcs -q
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">------ Message Queues --------
</span></span><span class="line"><span class="cl">key        msqid      owner      perms      used-bytes   messages
</span></span><span class="line"><span class="cl">0xd20097a6 4          root       600        36           3
</span></span></code></pre></td></tr></table>
</div>
</div><p>可以看到，我们执行了三次 ./msgsend，所以最终产生了 3 条消息，占用空间 36 字节，而我们发送的消息“hello world!”正好占用 12 字节，3 条就是 36 字节；</p>
<p><strong>msgrcv API 接收消息</strong></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">#include &lt;sys/types.h&gt;
</span></span><span class="line"><span class="cl">#include &lt;sys/ipc.h&gt;
</span></span><span class="line"><span class="cl">#include &lt;sys/msg.h&gt;
</span></span><span class="line"><span class="cl">#include &lt;stdlib.h&gt;
</span></span><span class="line"><span class="cl">#include &lt;stdio.h&gt;
</span></span><span class="line"><span class="cl">#include &lt;string.h&gt;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">#define FILEPATH &#34;/etc/passwd&#34;
</span></span><span class="line"><span class="cl">#define PROJID 1234
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">struct msgbuf {
</span></span><span class="line"><span class="cl">    long mtype;
</span></span><span class="line"><span class="cl">    char mtext[BUFSIZ];
</span></span><span class="line"><span class="cl">};
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">int main()
</span></span><span class="line"><span class="cl">{
</span></span><span class="line"><span class="cl">    int msgid;
</span></span><span class="line"><span class="cl">    key_t key;
</span></span><span class="line"><span class="cl">    struct msgbuf buf;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    key = ftok(FILEPATH, PROJID);
</span></span><span class="line"><span class="cl">    if (key == -1) {
</span></span><span class="line"><span class="cl">        perror(&#34;ftok()&#34;);
</span></span><span class="line"><span class="cl">        exit(1);
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    msgid = msgget(key, 0);
</span></span><span class="line"><span class="cl">    if (msgid == -1) {
</span></span><span class="line"><span class="cl">        perror(&#34;msgget()&#34;);
</span></span><span class="line"><span class="cl">        exit(1);
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    if (msgrcv(msgid, &amp;buf, BUFSIZ, 1, 0) == -1) {
</span></span><span class="line"><span class="cl">        perror(&#34;msgrcv()&#34;);
</span></span><span class="line"><span class="cl">        exit(1);
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    printf(&#34;mtype: %d\n&#34;, buf.mtype);
</span></span><span class="line"><span class="cl">    printf(&#34;mtype: %s\n&#34;, buf.mtext);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    //if (msgctl(msgid, IPC_RMID, NULL) == -1) {
</span></span><span class="line"><span class="cl">    //    perror(&#34;msgctl()&#34;);
</span></span><span class="line"><span class="cl">    //    exit(1);
</span></span><span class="line"><span class="cl">    //}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    exit(0);
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>编译运行并使用 ipcs -q 命令查看到，消息队列中只剩下一条消息了。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">$ gcc msg_receive.c -o msgrecv
</span></span><span class="line"><span class="cl">$ ./msgrecv
</span></span><span class="line"><span class="cl">mtype: 1
</span></span><span class="line"><span class="cl">mtype: hello world!
</span></span><span class="line"><span class="cl">$ ./msgrecv
</span></span><span class="line"><span class="cl">mtype: 1
</span></span><span class="line"><span class="cl">mtype: hello world!
</span></span><span class="line"><span class="cl">$ ipcs -q
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">------ Message Queues --------
</span></span><span class="line"><span class="cl">key        msqid      owner      perms      used-bytes   messages
</span></span><span class="line"><span class="cl">0xd20097a6 4          root       600        12           1
</span></span></code></pre></td></tr></table>
</div>
</div><p>简单说说 msgrcv() 的参数运用，先看下原型。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">int msgsnd(int msqid, const void *msgp, size_t msgsz, int msgflg);
</span></span><span class="line"><span class="cl">ssize_t msgrcv(int msqid, void *msgp, size_t msgsz, long msgtyp, int msgflg);
</span></span></code></pre></td></tr></table>
</div>
</div><p>其中，用 msgrcv 读取消息时，</p>
<ul>
<li>msgsz 参数，当消息本身内容大于缓冲区长度时，取决于 msgflg 参数是否设置了 MSG_NOERROR。
<ul>
<li>如果设置了，消息内容将被截短，消息剩余部分将会丢失。</li>
<li>如果没设置，msgrcv 会返回失败，并且 errno 被设定为 E2BIG。</li>
</ul>
</li>
<li>msgtyp 参数如果设置为 0，则无论什么类型，取队列中的第一个消息。如果值大于 0，则读取符合这个类型的第一个消息。</li>
<li>msgflag 参数还可以设置 IPC_NOWAIT，非阻塞方式读取。当队列为空的时候，msgrcv 会阻塞等待。加这个标志后将直接返回，errno 被设置为 ENOMSG。</li>
</ul>
<p>另外，Linux 系统对 XSI 消息队列的限制相关参数介绍。</p>
<ul>
<li>/proc/sys/kernel/msgmax：这个文件限制了系统中单个消息最大的字节数。</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">$ cat /proc/sys/kernel/msgmax
</span></span><span class="line"><span class="cl">8192
</span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>/proc/sys/kernel/msgmni：这个文件限制了系统中可创建的最大消息队列个数。</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">$ cat /proc/sys/kernel/msgmni
</span></span><span class="line"><span class="cl">32000
</span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>/proc/sys/kernel/msgmnb：这个文件用来限制单个消息队列中可以存放的最大消息字节数。</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">cat /proc/sys/kernel/msgmnb
</span></span><span class="line"><span class="cl">16384
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="posix-消息队列">POSIX 消息队列</h3>
<p>在 /dev/mqueue/ 下创建一个 tmpfs，然后用作消息队列的通信媒介。比 XSI 唯一占优势的地方在于消息队列可以用 select、poll、epoll 多路复用监听。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span><span class="lnt">70
</span><span class="lnt">71
</span><span class="lnt">72
</span><span class="lnt">73
</span><span class="lnt">74
</span><span class="lnt">75
</span><span class="lnt">76
</span><span class="lnt">77
</span><span class="lnt">78
</span><span class="lnt">79
</span><span class="lnt">80
</span><span class="lnt">81
</span><span class="lnt">82
</span><span class="lnt">83
</span><span class="lnt">84
</span><span class="lnt">85
</span><span class="lnt">86
</span><span class="lnt">87
</span><span class="lnt">88
</span><span class="lnt">89
</span><span class="lnt">90
</span><span class="lnt">91
</span><span class="lnt">92
</span><span class="lnt">93
</span><span class="lnt">94
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">#include &lt;fcntl.h&gt;
</span></span><span class="line"><span class="cl">#include &lt;sys/stat.h&gt;
</span></span><span class="line"><span class="cl">#include &lt;mqueue.h&gt;
</span></span><span class="line"><span class="cl">#include &lt;stdlib.h&gt;
</span></span><span class="line"><span class="cl">#include &lt;stdio.h&gt;
</span></span><span class="line"><span class="cl">#include &lt;errno.h&gt;
</span></span><span class="line"><span class="cl">#include &lt;string.h&gt;
</span></span><span class="line"><span class="cl">#include &lt;sys/epoll.h&gt;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">#define MQNAME &#34;/mqtest&#34;
</span></span><span class="line"><span class="cl">#define EPSIZE 10
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">int main()
</span></span><span class="line"><span class="cl">{
</span></span><span class="line"><span class="cl">    mqd_t mqd;
</span></span><span class="line"><span class="cl">    int ret, epfd, val, count;
</span></span><span class="line"><span class="cl">    char buf[BUFSIZ];
</span></span><span class="line"><span class="cl">    struct mq_attr new, old;
</span></span><span class="line"><span class="cl">    struct epoll_event ev, rev;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	mqd = mq_open(MQNAME, O_RDWR|O_CREAT, 0600, NULL);
</span></span><span class="line"><span class="cl">	if (mqd == -1) { /* 如果文件已存在 */
</span></span><span class="line"><span class="cl">		mqd = mq_open(MQNAME, O_RDWR);
</span></span><span class="line"><span class="cl">		if (mqd == -1) {
</span></span><span class="line"><span class="cl">			perror(&#34;mq_open()&#34;);
</span></span><span class="line"><span class="cl">			exit(1);
</span></span><span class="line"><span class="cl">		}
</span></span><span class="line"><span class="cl">	}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    /* 因为有epoll帮我们等待描述符是否可读，所以对 mqd 的处理可以设置为非阻塞 */
</span></span><span class="line"><span class="cl">    new.mq_flags = O_NONBLOCK;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    if (mq_setattr(mqd, &amp;new, &amp;old) == -1) {
</span></span><span class="line"><span class="cl">        perror(&#34;mq_setattr()&#34;);
</span></span><span class="line"><span class="cl">        exit(1);
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    epfd = epoll_create(EPSIZE);
</span></span><span class="line"><span class="cl">    if (epfd &lt; 0) {
</span></span><span class="line"><span class="cl">        perror(&#34;epoll_create()&#34;);
</span></span><span class="line"><span class="cl">        exit(1);
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    /* 关注描述符是否可读 */
</span></span><span class="line"><span class="cl">    ev.events = EPOLLIN;
</span></span><span class="line"><span class="cl">    ev.data.fd = mqd;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    ret = epoll_ctl(epfd, EPOLL_CTL_ADD, mqd, &amp;ev);
</span></span><span class="line"><span class="cl">    if (ret &lt; 0) {
</span></span><span class="line"><span class="cl">        perror(&#34;epoll_ctl()&#34;);
</span></span><span class="line"><span class="cl">        exit(1);
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    while (1) {
</span></span><span class="line"><span class="cl">        ret = epoll_wait(epfd, &amp;rev, EPSIZE, -1);
</span></span><span class="line"><span class="cl">        if (ret &lt; 0) {
</span></span><span class="line"><span class="cl">            /* 如果被信号打断则继续epoll_wait */
</span></span><span class="line"><span class="cl">            if (errno == EINTR) {
</span></span><span class="line"><span class="cl">                continue;
</span></span><span class="line"><span class="cl">            } else {
</span></span><span class="line"><span class="cl">                perror(&#34;epoll_wait()&#34;);
</span></span><span class="line"><span class="cl">                exit(1);
</span></span><span class="line"><span class="cl">            }
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        /* 此处处理所有返回的描述符（虽然本例子中只有一个） */
</span></span><span class="line"><span class="cl">        for (count=0;count&lt;ret;count++) {
</span></span><span class="line"><span class="cl">            ret = mq_receive(rev.data.fd, buf, BUFSIZ, &amp;val);
</span></span><span class="line"><span class="cl">            if (ret == -1) {
</span></span><span class="line"><span class="cl">                if (errno == EAGAIN) {
</span></span><span class="line"><span class="cl">                    break;
</span></span><span class="line"><span class="cl">                }
</span></span><span class="line"><span class="cl">                perror(&#34;mq_receive()&#34;);
</span></span><span class="line"><span class="cl">                exit(1);
</span></span><span class="line"><span class="cl">            }
</span></span><span class="line"><span class="cl">            printf(&#34;msq: %s, prio: %d\n&#34;, buf, val);
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    /* 恢复描述符的flag */
</span></span><span class="line"><span class="cl">    if (mq_setattr(mqd, &amp;old, NULL) == -1) {
</span></span><span class="line"><span class="cl">        perror(&#34;mq_setattr()&#34;);
</span></span><span class="line"><span class="cl">        exit(1);
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    ret = mq_close(mqd);
</span></span><span class="line"><span class="cl">    if (ret == -1) {
</span></span><span class="line"><span class="cl">        perror(&#34;mp_close()&#34;);
</span></span><span class="line"><span class="cl">        exit(1);
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">    exit(0);
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>发送消息代码。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">int main(int argc, char *argv[]) {
</span></span><span class="line"><span class="cl">    mqd_t mqd;
</span></span><span class="line"><span class="cl">    int ret;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    if (argc != 3) {
</span></span><span class="line"><span class="cl">        fprintf(stderr, &#34;Argument error!\n&#34;);
</span></span><span class="line"><span class="cl">        exit(1);
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    mqd = mq_open(MQNAME, O_RDWR|O_CREAT, 0600, NULL);
</span></span><span class="line"><span class="cl">    if (mqd == -1) {
</span></span><span class="line"><span class="cl">        perror(&#34;mq_open()&#34;);
</span></span><span class="line"><span class="cl">        exit(1);
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    ret = mq_send(mqd, argv[1], strlen(argv[1]), atoi(argv[2]));
</span></span><span class="line"><span class="cl">    if (ret == -1) {
</span></span><span class="line"><span class="cl">        perror(&#34;mq_send()&#34;);
</span></span><span class="line"><span class="cl">        exit(1);
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    exit(0);
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>编译运行：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">$ gcc send.c -o ./send -lrt$ ./send pro 111
</span></span><span class="line"><span class="cl">$ ./send pro 222
</span></span><span class="line"><span class="cl">$ cat /dev/mqueue/mqtest
</span></span><span class="line"><span class="cl">QSIZE:102        NOTIFY:0     SIGNO:0     NOTIFY_PID:0
</span></span><span class="line"><span class="cl">$ ./send pro 333
</span></span><span class="line"><span class="cl">$ cat /dev/mqueue/mqtest
</span></span><span class="line"><span class="cl">QSIZE:153        NOTIFY:0     SIGNO:0     NOTIFY_PID:0
</span></span><span class="line"><span class="cl">$ ./send pro 3
</span></span><span class="line"><span class="cl">$ cat /dev/mqueue/mqtest
</span></span><span class="line"><span class="cl">QSIZE:204        NOTIFY:0     SIGNO:0     NOTIFY_PID:0
</span></span></code></pre></td></tr></table>
</div>
</div><p>POSIX 消息队列的一些参数文件：</p>
<ul>
<li>/proc/sys/fs/mqueue/msg_default：在mq_open的attr参数设置为NULL的时候，这个文件中的数字限定了mq_maxmsg的值，就是队列的消息个数限制。默认为10个，当消息数达到上限之后，再使用mq_send发送消息会阻塞。</li>
<li>/proc/sys/fs/mqueue/msg_max：可以通过mq_open的attr参数设定的mq_maxmsg的数字上限。这个值默认也是10。</li>
<li>/proc/sys/fs/mqueue/msgsize_default：在mq_open的attr参数设置为NULL的时候，这个文件中的数字限定了mq_msgsize的值，就是队列的字节数数限制。</li>
<li>/proc/sys/fs/mqueue/msgsize_max：可以通过mq_open的attr参数设定的mq_msgsize的数字上限。</li>
<li>/proc/sys/fs/mqueue/queues_max：系统可以创建的消息队列个数上限。</li>
</ul>
<p><big><strong>小结</strong></big></p>
<ol>
<li>Linux 有两种消息队列：XSI、POSIX；</li>
<li>这两种消息队列的删除都需要通过手工进行，XSI 可以在 ipcs 看到，POSIX 可以在 /dev/mqueue/ 目录下看到；</li>
<li>POSIX 消息队列比 XSI 占优势的一点就是可以用 select、poll、epoll 对文件描述符监听，以达到更高效的异步处理方式。</li>
</ol>
<h2 id="信号量">信号量</h2>
<p>信号量就是在临界区门口放一个盒子，盒子里面装着固定数量的小球。</p>
<ul>
<li>每个线程进来的时候，都要从盒子里面取走一个小球，然后才能去临界区里玩耍；</li>
<li>等出来的时候，再把小球放回盒子里。</li>
</ul>
<p>如果一个线程走过来一摸盒子，发现一个球都没了，因为不拿球不让进，所以只能站在门口等一个线程出来放回一个球，当前线程取出小球再进临界区。</p>
<p>由于小球的数量是固定的，那么临界区里面的最大线程数量就是固定的，不会出现一下进去太多线程把临界区给挤爆的情况。然后，只放一个小球的盒子用作信号量，就根互斥锁没啥区别了。</p>
<p>另外一些情况下，小球是一次性的，线程拿走一个进了门，就把小球扔掉了，这样用着用着小球就没了，不过有另外一些线程（一般叫做生产者）会时不时过来往盒子里再放几个球，这样就可以有新的线程（一般叫做消费者）进去了，放一个球就进一个线程，这是信号量做同步功能。通过sem_post往盒子里放小球（信号量加一），而其他线程是消费者，通过sem_wait从盒子里拿小球（信号量减一），如果遇到盒子里一个小球都没有（信号量为0），就等待信号量不为0（生产线程又放小球进来），然后拿走一个小球（信号量减一）再继续。</p>
<p>所以，本质上来说信号量就是那个盒子加上“摸不到球就不让进”这个机制的实现。sem_post（放小球）操作不会阻塞，sem_wait（取小球）操作会阻塞（当盒子里没球，也就是信号量值为 0 的时候）。</p>
<p>P = passeren，中文译为&quot;通过&quot;，V = vrijgeven，中文译为&quot;释放&quot;</p>
<h3 id="xsi-信号量">XSI 信号量</h3>
<p>通过共享内存累加计数，通过XSI信号量实现PV语义进行加锁和解锁。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">  1
</span><span class="lnt">  2
</span><span class="lnt">  3
</span><span class="lnt">  4
</span><span class="lnt">  5
</span><span class="lnt">  6
</span><span class="lnt">  7
</span><span class="lnt">  8
</span><span class="lnt">  9
</span><span class="lnt"> 10
</span><span class="lnt"> 11
</span><span class="lnt"> 12
</span><span class="lnt"> 13
</span><span class="lnt"> 14
</span><span class="lnt"> 15
</span><span class="lnt"> 16
</span><span class="lnt"> 17
</span><span class="lnt"> 18
</span><span class="lnt"> 19
</span><span class="lnt"> 20
</span><span class="lnt"> 21
</span><span class="lnt"> 22
</span><span class="lnt"> 23
</span><span class="lnt"> 24
</span><span class="lnt"> 25
</span><span class="lnt"> 26
</span><span class="lnt"> 27
</span><span class="lnt"> 28
</span><span class="lnt"> 29
</span><span class="lnt"> 30
</span><span class="lnt"> 31
</span><span class="lnt"> 32
</span><span class="lnt"> 33
</span><span class="lnt"> 34
</span><span class="lnt"> 35
</span><span class="lnt"> 36
</span><span class="lnt"> 37
</span><span class="lnt"> 38
</span><span class="lnt"> 39
</span><span class="lnt"> 40
</span><span class="lnt"> 41
</span><span class="lnt"> 42
</span><span class="lnt"> 43
</span><span class="lnt"> 44
</span><span class="lnt"> 45
</span><span class="lnt"> 46
</span><span class="lnt"> 47
</span><span class="lnt"> 48
</span><span class="lnt"> 49
</span><span class="lnt"> 50
</span><span class="lnt"> 51
</span><span class="lnt"> 52
</span><span class="lnt"> 53
</span><span class="lnt"> 54
</span><span class="lnt"> 55
</span><span class="lnt"> 56
</span><span class="lnt"> 57
</span><span class="lnt"> 58
</span><span class="lnt"> 59
</span><span class="lnt"> 60
</span><span class="lnt"> 61
</span><span class="lnt"> 62
</span><span class="lnt"> 63
</span><span class="lnt"> 64
</span><span class="lnt"> 65
</span><span class="lnt"> 66
</span><span class="lnt"> 67
</span><span class="lnt"> 68
</span><span class="lnt"> 69
</span><span class="lnt"> 70
</span><span class="lnt"> 71
</span><span class="lnt"> 72
</span><span class="lnt"> 73
</span><span class="lnt"> 74
</span><span class="lnt"> 75
</span><span class="lnt"> 76
</span><span class="lnt"> 77
</span><span class="lnt"> 78
</span><span class="lnt"> 79
</span><span class="lnt"> 80
</span><span class="lnt"> 81
</span><span class="lnt"> 82
</span><span class="lnt"> 83
</span><span class="lnt"> 84
</span><span class="lnt"> 85
</span><span class="lnt"> 86
</span><span class="lnt"> 87
</span><span class="lnt"> 88
</span><span class="lnt"> 89
</span><span class="lnt"> 90
</span><span class="lnt"> 91
</span><span class="lnt"> 92
</span><span class="lnt"> 93
</span><span class="lnt"> 94
</span><span class="lnt"> 95
</span><span class="lnt"> 96
</span><span class="lnt"> 97
</span><span class="lnt"> 98
</span><span class="lnt"> 99
</span><span class="lnt">100
</span><span class="lnt">101
</span><span class="lnt">102
</span><span class="lnt">103
</span><span class="lnt">104
</span><span class="lnt">105
</span><span class="lnt">106
</span><span class="lnt">107
</span><span class="lnt">108
</span><span class="lnt">109
</span><span class="lnt">110
</span><span class="lnt">111
</span><span class="lnt">112
</span><span class="lnt">113
</span><span class="lnt">114
</span><span class="lnt">115
</span><span class="lnt">116
</span><span class="lnt">117
</span><span class="lnt">118
</span><span class="lnt">119
</span><span class="lnt">120
</span><span class="lnt">121
</span><span class="lnt">122
</span><span class="lnt">123
</span><span class="lnt">124
</span><span class="lnt">125
</span><span class="lnt">126
</span><span class="lnt">127
</span><span class="lnt">128
</span><span class="lnt">129
</span><span class="lnt">130
</span><span class="lnt">131
</span><span class="lnt">132
</span><span class="lnt">133
</span><span class="lnt">134
</span><span class="lnt">135
</span><span class="lnt">136
</span><span class="lnt">137
</span><span class="lnt">138
</span><span class="lnt">139
</span><span class="lnt">140
</span><span class="lnt">141
</span><span class="lnt">142
</span><span class="lnt">143
</span><span class="lnt">144
</span><span class="lnt">145
</span><span class="lnt">146
</span><span class="lnt">147
</span><span class="lnt">148
</span><span class="lnt">149
</span><span class="lnt">150
</span><span class="lnt">151
</span><span class="lnt">152
</span><span class="lnt">153
</span><span class="lnt">154
</span><span class="lnt">155
</span><span class="lnt">156
</span><span class="lnt">157
</span><span class="lnt">158
</span><span class="lnt">159
</span><span class="lnt">160
</span><span class="lnt">161
</span><span class="lnt">162
</span><span class="lnt">163
</span><span class="lnt">164
</span><span class="lnt">165
</span><span class="lnt">166
</span><span class="lnt">167
</span><span class="lnt">168
</span><span class="lnt">169
</span><span class="lnt">170
</span><span class="lnt">171
</span><span class="lnt">172
</span><span class="lnt">173
</span><span class="lnt">174
</span><span class="lnt">175
</span><span class="lnt">176
</span><span class="lnt">177
</span><span class="lnt">178
</span><span class="lnt">179
</span><span class="lnt">180
</span><span class="lnt">181
</span><span class="lnt">182
</span><span class="lnt">183
</span><span class="lnt">184
</span><span class="lnt">185
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">#include &lt;unistd.h&gt;
</span></span><span class="line"><span class="cl">#include &lt;stdlib.h&gt;
</span></span><span class="line"><span class="cl">#include &lt;stdio.h&gt;
</span></span><span class="line"><span class="cl">#include &lt;errno.h&gt;
</span></span><span class="line"><span class="cl">#include &lt;fcntl.h&gt;
</span></span><span class="line"><span class="cl">#include &lt;string.h&gt;
</span></span><span class="line"><span class="cl">#include &lt;sys/file.h&gt;
</span></span><span class="line"><span class="cl">#include &lt;wait.h&gt;
</span></span><span class="line"><span class="cl">#include &lt;sys/mman.h&gt;
</span></span><span class="line"><span class="cl">#include &lt;sys/ipc.h&gt;
</span></span><span class="line"><span class="cl">#include &lt;sys/shm.h&gt;
</span></span><span class="line"><span class="cl">#include &lt;sys/types.h&gt;
</span></span><span class="line"><span class="cl">#include &lt;sys/sem.h&gt;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">#define COUNT 100
</span></span><span class="line"><span class="cl">#define PATHNAME &#34;/etc/passwd&#34;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">static int lockid;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">int mylock_init(void)
</span></span><span class="line"><span class="cl">{
</span></span><span class="line"><span class="cl">    int semid;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    semid = semget(IPC_PRIVATE, 1, IPC_CREAT|0600);
</span></span><span class="line"><span class="cl">    if (semid &lt; 0) {
</span></span><span class="line"><span class="cl">        perror(&#34;semget()&#34;);
</span></span><span class="line"><span class="cl">        return -1;
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">    if (semctl(semid, 0, SETVAL, 1) &lt; 0) {
</span></span><span class="line"><span class="cl">        perror(&#34;semctl()&#34;);
</span></span><span class="line"><span class="cl">        return -1;
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">    return semid;
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">void mylock_destroy(int lockid)
</span></span><span class="line"><span class="cl">{
</span></span><span class="line"><span class="cl">    semctl(lockid, 0, IPC_RMID);
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">int mylock(int lockid)
</span></span><span class="line"><span class="cl">{
</span></span><span class="line"><span class="cl">    struct sembuf sbuf;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    sbuf.sem_num = 0; // 除非使用一组信号量，否则它为0
</span></span><span class="line"><span class="cl">    sbuf.sem_op = -1; // -1，即P（等待）操作， +1，即V（发送信号）操作
</span></span><span class="line"><span class="cl">    sbuf.sem_flg = 0; // 通常为SEM_UNDO,使操作系统跟踪信号量， 并在进程没有释放该信号量而终止时，操作系统释放信号量
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    while (semop(lockid, &amp;sbuf, 1) &lt; 0) {
</span></span><span class="line"><span class="cl">        if (errno == EINTR) {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">            continue;
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">        perror(&#34;semop()&#34;);
</span></span><span class="line"><span class="cl">        return -1;
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    return 0;
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">int myunlock(int lockid)
</span></span><span class="line"><span class="cl">{
</span></span><span class="line"><span class="cl">    struct sembuf sbuf;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    sbuf.sem_num = 0;
</span></span><span class="line"><span class="cl">    sbuf.sem_op = 1; // +1，即V（发送信号）操作
</span></span><span class="line"><span class="cl">    sbuf.sem_flg = 0;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    if (semop(lockid, &amp;sbuf, 1) &lt; 0) {
</span></span><span class="line"><span class="cl">        perror(&#34;semop()&#34;);
</span></span><span class="line"><span class="cl">        return -1;
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    return 0;
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">int do_child(int proj_id)
</span></span><span class="line"><span class="cl">{
</span></span><span class="line"><span class="cl">    int interval;
</span></span><span class="line"><span class="cl">    int *shm_p, shm_id;
</span></span><span class="line"><span class="cl">    key_t shm_key;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    if ((shm_key = ftok(PATHNAME, proj_id)) == -1) {
</span></span><span class="line"><span class="cl">        perror(&#34;ftok()&#34;);
</span></span><span class="line"><span class="cl">        exit(1);
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    shm_id = shmget(shm_key, sizeof(int), 0);
</span></span><span class="line"><span class="cl">    if (shm_id &lt; 0) {
</span></span><span class="line"><span class="cl">        perror(&#34;shmget()&#34;);
</span></span><span class="line"><span class="cl">        exit(1);
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    shm_p = (int *)shmat(shm_id, NULL, 0);
</span></span><span class="line"><span class="cl">    if ((void *)shm_p == (void *)-1) {
</span></span><span class="line"><span class="cl">        perror(&#34;shmat()&#34;);
</span></span><span class="line"><span class="cl">        exit(1);
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    /* critical section */
</span></span><span class="line"><span class="cl">    if (mylock(lockid) == -1) {
</span></span><span class="line"><span class="cl">        exit(1);
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">    interval = *shm_p;
</span></span><span class="line"><span class="cl">    interval++;
</span></span><span class="line"><span class="cl">    usleep(1);
</span></span><span class="line"><span class="cl">    *shm_p = interval;
</span></span><span class="line"><span class="cl">    if (myunlock(lockid) == -1) {
</span></span><span class="line"><span class="cl">        exit(1);
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">    /* critical section */
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    if (shmdt(shm_p) &lt; 0) {
</span></span><span class="line"><span class="cl">        perror(&#34;shmdt()&#34;);
</span></span><span class="line"><span class="cl">        exit(1);
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    exit(0);
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">int main()
</span></span><span class="line"><span class="cl">{
</span></span><span class="line"><span class="cl">    pid_t pid;
</span></span><span class="line"><span class="cl">    int count;
</span></span><span class="line"><span class="cl">    int *shm_p;
</span></span><span class="line"><span class="cl">    int shm_id, proj_id;
</span></span><span class="line"><span class="cl">    key_t shm_key;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    lockid = mylock_init();
</span></span><span class="line"><span class="cl">    if (lockid == -1) {
</span></span><span class="line"><span class="cl">        exit(1);
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    proj_id = 1234;
</span></span><span class="line"><span class="cl">    if ((shm_key = ftok(PATHNAME, proj_id)) == -1) {
</span></span><span class="line"><span class="cl">        perror(&#34;ftok()&#34;);
</span></span><span class="line"><span class="cl">        exit(1);
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    shm_id = shmget(shm_key, sizeof(int), IPC_CREAT|IPC_EXCL|0600);
</span></span><span class="line"><span class="cl">    if (shm_id &lt; 0) {
</span></span><span class="line"><span class="cl">        perror(&#34;shmget()&#34;);
</span></span><span class="line"><span class="cl">        exit(1);
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    shm_p = (int *)shmat(shm_id, NULL, 0);
</span></span><span class="line"><span class="cl">    if ((void *)shm_p == (void *)-1) {
</span></span><span class="line"><span class="cl">        perror(&#34;shmat()&#34;);
</span></span><span class="line"><span class="cl">        exit(1);
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    *shm_p = 0;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    for (count=0;count&lt;COUNT;count++) {
</span></span><span class="line"><span class="cl">        pid = fork();
</span></span><span class="line"><span class="cl">        if (pid &lt; 0) {
</span></span><span class="line"><span class="cl">            perror(&#34;fork()&#34;);
</span></span><span class="line"><span class="cl">            exit(1);
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        if (pid == 0) {
</span></span><span class="line"><span class="cl">            do_child(proj_id);
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    for (count=0;count&lt;COUNT;count++) {
</span></span><span class="line"><span class="cl">        wait(NULL);
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    printf(&#34;shm_p: %d\n&#34;, *shm_p);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    if (shmdt(shm_p) &lt; 0) {
</span></span><span class="line"><span class="cl">        perror(&#34;shmdt()&#34;);
</span></span><span class="line"><span class="cl">        exit(1);
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    if (shmctl(shm_id, IPC_RMID, NULL) &lt; 0) {
</span></span><span class="line"><span class="cl">        perror(&#34;shmctl()&#34;);
</span></span><span class="line"><span class="cl">        exit(1);
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    mylock_destroy(lockid);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    exit(0);
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>编译运行，得到的是正确的结果：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">$ ./racing_xsi_shm 
</span></span><span class="line"><span class="cl">shm_p: 100
</span></span></code></pre></td></tr></table>
</div>
</div><p>系统中对于XSI信号量的限制都放在一个文件中，路径为：/proc/sys/kernel/sem 文件中包涵4个限制值，它们分别的含义是：</p>
<ul>
<li>
<p>SEMMSL：一个信号量集（semaphore set）中，最多可以有多少个信号量。这个限制实际上就是semget调用的第二个参数的个数上限。</p>
</li>
<li>
<p>SEMMNS：系统中在所有信号量集中最多可以有多少个信号量。</p>
</li>
<li>
<p>SEMOPM：可以使用semop系统调用指定的操作数限制。这个实际上是semop调用中，第二个参数的结构体中的sem_op的数字上限。</p>
</li>
<li>
<p>SEMMNI：系统中信号量的id标示数限制。就是信号量集的个数上限。</p>
</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">$ cat /proc/sys/kernel/sem
</span></span><span class="line"><span class="cl">250     32000   32      128
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="posix-命名信号量">POSIX 命名信号量</h3>
<p>命名信号量跟 POSIX 共享内存类似，也会在/dev/shm目录下创建一个文件，其它进程可以通过这个文件名来通过 sem_open 方法使用这个信号量。</p>
<p>可以使用 sem_wait、sem_post 等方法进行操作。需要注意的是，一个命名信号量在用 sem_close 关闭之后，还要使用 sem_unlink 删除其文件名，才算彻底被删除。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">  1
</span><span class="lnt">  2
</span><span class="lnt">  3
</span><span class="lnt">  4
</span><span class="lnt">  5
</span><span class="lnt">  6
</span><span class="lnt">  7
</span><span class="lnt">  8
</span><span class="lnt">  9
</span><span class="lnt"> 10
</span><span class="lnt"> 11
</span><span class="lnt"> 12
</span><span class="lnt"> 13
</span><span class="lnt"> 14
</span><span class="lnt"> 15
</span><span class="lnt"> 16
</span><span class="lnt"> 17
</span><span class="lnt"> 18
</span><span class="lnt"> 19
</span><span class="lnt"> 20
</span><span class="lnt"> 21
</span><span class="lnt"> 22
</span><span class="lnt"> 23
</span><span class="lnt"> 24
</span><span class="lnt"> 25
</span><span class="lnt"> 26
</span><span class="lnt"> 27
</span><span class="lnt"> 28
</span><span class="lnt"> 29
</span><span class="lnt"> 30
</span><span class="lnt"> 31
</span><span class="lnt"> 32
</span><span class="lnt"> 33
</span><span class="lnt"> 34
</span><span class="lnt"> 35
</span><span class="lnt"> 36
</span><span class="lnt"> 37
</span><span class="lnt"> 38
</span><span class="lnt"> 39
</span><span class="lnt"> 40
</span><span class="lnt"> 41
</span><span class="lnt"> 42
</span><span class="lnt"> 43
</span><span class="lnt"> 44
</span><span class="lnt"> 45
</span><span class="lnt"> 46
</span><span class="lnt"> 47
</span><span class="lnt"> 48
</span><span class="lnt"> 49
</span><span class="lnt"> 50
</span><span class="lnt"> 51
</span><span class="lnt"> 52
</span><span class="lnt"> 53
</span><span class="lnt"> 54
</span><span class="lnt"> 55
</span><span class="lnt"> 56
</span><span class="lnt"> 57
</span><span class="lnt"> 58
</span><span class="lnt"> 59
</span><span class="lnt"> 60
</span><span class="lnt"> 61
</span><span class="lnt"> 62
</span><span class="lnt"> 63
</span><span class="lnt"> 64
</span><span class="lnt"> 65
</span><span class="lnt"> 66
</span><span class="lnt"> 67
</span><span class="lnt"> 68
</span><span class="lnt"> 69
</span><span class="lnt"> 70
</span><span class="lnt"> 71
</span><span class="lnt"> 72
</span><span class="lnt"> 73
</span><span class="lnt"> 74
</span><span class="lnt"> 75
</span><span class="lnt"> 76
</span><span class="lnt"> 77
</span><span class="lnt"> 78
</span><span class="lnt"> 79
</span><span class="lnt"> 80
</span><span class="lnt"> 81
</span><span class="lnt"> 82
</span><span class="lnt"> 83
</span><span class="lnt"> 84
</span><span class="lnt"> 85
</span><span class="lnt"> 86
</span><span class="lnt"> 87
</span><span class="lnt"> 88
</span><span class="lnt"> 89
</span><span class="lnt"> 90
</span><span class="lnt"> 91
</span><span class="lnt"> 92
</span><span class="lnt"> 93
</span><span class="lnt"> 94
</span><span class="lnt"> 95
</span><span class="lnt"> 96
</span><span class="lnt"> 97
</span><span class="lnt"> 98
</span><span class="lnt"> 99
</span><span class="lnt">100
</span><span class="lnt">101
</span><span class="lnt">102
</span><span class="lnt">103
</span><span class="lnt">104
</span><span class="lnt">105
</span><span class="lnt">106
</span><span class="lnt">107
</span><span class="lnt">108
</span><span class="lnt">109
</span><span class="lnt">110
</span><span class="lnt">111
</span><span class="lnt">112
</span><span class="lnt">113
</span><span class="lnt">114
</span><span class="lnt">115
</span><span class="lnt">116
</span><span class="lnt">117
</span><span class="lnt">118
</span><span class="lnt">119
</span><span class="lnt">120
</span><span class="lnt">121
</span><span class="lnt">122
</span><span class="lnt">123
</span><span class="lnt">124
</span><span class="lnt">125
</span><span class="lnt">126
</span><span class="lnt">127
</span><span class="lnt">128
</span><span class="lnt">129
</span><span class="lnt">130
</span><span class="lnt">131
</span><span class="lnt">132
</span><span class="lnt">133
</span><span class="lnt">134
</span><span class="lnt">135
</span><span class="lnt">136
</span><span class="lnt">137
</span><span class="lnt">138
</span><span class="lnt">139
</span><span class="lnt">140
</span><span class="lnt">141
</span><span class="lnt">142
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">#include &lt;unistd.h&gt;
</span></span><span class="line"><span class="cl">#include &lt;stdlib.h&gt;
</span></span><span class="line"><span class="cl">#include &lt;stdio.h&gt;
</span></span><span class="line"><span class="cl">#include &lt;errno.h&gt;
</span></span><span class="line"><span class="cl">#include &lt;fcntl.h&gt;
</span></span><span class="line"><span class="cl">#include &lt;string.h&gt;
</span></span><span class="line"><span class="cl">#include &lt;sys/file.h&gt;
</span></span><span class="line"><span class="cl">#include &lt;wait.h&gt;
</span></span><span class="line"><span class="cl">#include &lt;sys/mman.h&gt;
</span></span><span class="line"><span class="cl">#include &lt;sys/stat.h&gt;
</span></span><span class="line"><span class="cl">#include &lt;semaphore.h&gt;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">#define COUNT 100
</span></span><span class="line"><span class="cl">#define SHMPATH &#34;/shm&#34;
</span></span><span class="line"><span class="cl">#define SEMPATH &#34;/sem&#34;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">static sem_t *sem;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">sem_t *mylock_init(void)
</span></span><span class="line"><span class="cl">{
</span></span><span class="line"><span class="cl">    sem_t * ret;
</span></span><span class="line"><span class="cl">    ret = sem_open(SEMPATH, O_CREAT|O_EXCL, 0600, 1);
</span></span><span class="line"><span class="cl">    if (ret == SEM_FAILED) {
</span></span><span class="line"><span class="cl">        perror(&#34;sem_open()&#34;);
</span></span><span class="line"><span class="cl">        return NULL;
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">    return ret;
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">void mylock_destroy(sem_t *sem)
</span></span><span class="line"><span class="cl">{
</span></span><span class="line"><span class="cl">    sem_close(sem);
</span></span><span class="line"><span class="cl">    sem_unlink(SEMPATH);
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">int mylock(sem_t *sem)
</span></span><span class="line"><span class="cl">{
</span></span><span class="line"><span class="cl">    while (sem_wait(sem) &lt; 0) {
</span></span><span class="line"><span class="cl">        if (errno == EINTR) {
</span></span><span class="line"><span class="cl">            continue;
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">        perror(&#34;sem_wait()&#34;);
</span></span><span class="line"><span class="cl">        return -1;
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    return 0;
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">int myunlock(sem_t *sem)
</span></span><span class="line"><span class="cl">{
</span></span><span class="line"><span class="cl">    if (sem_post(sem) &lt; 0) {
</span></span><span class="line"><span class="cl">        perror(&#34;semop()&#34;);
</span></span><span class="line"><span class="cl">        return -1;
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">int do_child(char * shmpath)
</span></span><span class="line"><span class="cl">{
</span></span><span class="line"><span class="cl">    int interval, shmfd, ret;
</span></span><span class="line"><span class="cl">    int *shm_p;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    shmfd = shm_open(shmpath, O_RDWR, 0600);
</span></span><span class="line"><span class="cl">    if (shmfd &lt; 0) {
</span></span><span class="line"><span class="cl">        perror(&#34;shm_open()&#34;);
</span></span><span class="line"><span class="cl">        exit(1);
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    shm_p = (int *)mmap(NULL, sizeof(int), PROT_WRITE|PROT_READ, MAP_SHARED, shmfd, 0);
</span></span><span class="line"><span class="cl">    if (MAP_FAILED == shm_p) {
</span></span><span class="line"><span class="cl">        perror(&#34;mmap()&#34;);
</span></span><span class="line"><span class="cl">        exit(1);
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">    /* critical section */
</span></span><span class="line"><span class="cl">    mylock(sem);
</span></span><span class="line"><span class="cl">    interval = *shm_p;
</span></span><span class="line"><span class="cl">    interval++;
</span></span><span class="line"><span class="cl">    usleep(1);
</span></span><span class="line"><span class="cl">    *shm_p = interval;
</span></span><span class="line"><span class="cl">    myunlock(sem);
</span></span><span class="line"><span class="cl">    /* critical section */
</span></span><span class="line"><span class="cl">    munmap(shm_p, sizeof(int));
</span></span><span class="line"><span class="cl">    close(shmfd);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    exit(0);
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">int main()
</span></span><span class="line"><span class="cl">{
</span></span><span class="line"><span class="cl">    pid_t pid;
</span></span><span class="line"><span class="cl">    int count, shmfd, ret;
</span></span><span class="line"><span class="cl">    int *shm_p;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    sem = mylock_init();
</span></span><span class="line"><span class="cl">    if (sem == NULL) {
</span></span><span class="line"><span class="cl">        fprintf(stderr, &#34;mylock_init(): error!\n&#34;);
</span></span><span class="line"><span class="cl">        exit(1);
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    shmfd = shm_open(SHMPATH, O_RDWR|O_CREAT|O_TRUNC, 0600);
</span></span><span class="line"><span class="cl">    if (shmfd &lt; 0) {
</span></span><span class="line"><span class="cl">        perror(&#34;shm_open()&#34;);
</span></span><span class="line"><span class="cl">        exit(1);
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    ret = ftruncate(shmfd, sizeof(int));
</span></span><span class="line"><span class="cl">    if (ret &lt; 0) {
</span></span><span class="line"><span class="cl">        perror(&#34;ftruncate()&#34;);
</span></span><span class="line"><span class="cl">        exit(1);
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    shm_p = (int *)mmap(NULL, sizeof(int), PROT_WRITE|PROT_READ, MAP_SHARED, shmfd, 0);
</span></span><span class="line"><span class="cl">    if (MAP_FAILED == shm_p) {
</span></span><span class="line"><span class="cl">        perror(&#34;mmap()&#34;);
</span></span><span class="line"><span class="cl">        exit(1);
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    *shm_p = 0;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    for (count=0;count&lt;COUNT;count++) {
</span></span><span class="line"><span class="cl">        pid = fork();
</span></span><span class="line"><span class="cl">        if (pid &lt; 0) {
</span></span><span class="line"><span class="cl">            perror(&#34;fork()&#34;);
</span></span><span class="line"><span class="cl">            exit(1);
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        if (pid == 0) {
</span></span><span class="line"><span class="cl">            do_child(SHMPATH);
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    for (count=0;count&lt;COUNT;count++) {
</span></span><span class="line"><span class="cl">        wait(NULL);
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    printf(&#34;shm_p: %d\n&#34;, *shm_p);
</span></span><span class="line"><span class="cl">    munmap(shm_p, sizeof(int));
</span></span><span class="line"><span class="cl">    close(shmfd);
</span></span><span class="line"><span class="cl">    shm_unlink(SHMPATH);
</span></span><span class="line"><span class="cl">    sleep(3000);
</span></span><span class="line"><span class="cl">    mylock_destroy(sem);
</span></span><span class="line"><span class="cl">    exit(0);
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="posix-匿名信号量">POSIX 匿名信号量</h3>
<p>匿名信号量仅仅就是一段内存空间，并没有一个文件名与之对应。</p>
<p>匿名信号量使用 sem_init 进行初始化，使用 sem_destroy() 销毁，其它操作方法跟命名信号量一样。</p>
<p>如果匿名信号量是在一个进程中的多个线程中使用，那么它所在的内存区应该是这些线程应该都能访问到的全局变量或者 malloc 分配到的内存。</p>
<p>如果是在多个进程间共享，那么这段内存应该本身是一段共享内存（使用 mmap、shmget 或 shm_open 申请的内存）</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">  1
</span><span class="lnt">  2
</span><span class="lnt">  3
</span><span class="lnt">  4
</span><span class="lnt">  5
</span><span class="lnt">  6
</span><span class="lnt">  7
</span><span class="lnt">  8
</span><span class="lnt">  9
</span><span class="lnt"> 10
</span><span class="lnt"> 11
</span><span class="lnt"> 12
</span><span class="lnt"> 13
</span><span class="lnt"> 14
</span><span class="lnt"> 15
</span><span class="lnt"> 16
</span><span class="lnt"> 17
</span><span class="lnt"> 18
</span><span class="lnt"> 19
</span><span class="lnt"> 20
</span><span class="lnt"> 21
</span><span class="lnt"> 22
</span><span class="lnt"> 23
</span><span class="lnt"> 24
</span><span class="lnt"> 25
</span><span class="lnt"> 26
</span><span class="lnt"> 27
</span><span class="lnt"> 28
</span><span class="lnt"> 29
</span><span class="lnt"> 30
</span><span class="lnt"> 31
</span><span class="lnt"> 32
</span><span class="lnt"> 33
</span><span class="lnt"> 34
</span><span class="lnt"> 35
</span><span class="lnt"> 36
</span><span class="lnt"> 37
</span><span class="lnt"> 38
</span><span class="lnt"> 39
</span><span class="lnt"> 40
</span><span class="lnt"> 41
</span><span class="lnt"> 42
</span><span class="lnt"> 43
</span><span class="lnt"> 44
</span><span class="lnt"> 45
</span><span class="lnt"> 46
</span><span class="lnt"> 47
</span><span class="lnt"> 48
</span><span class="lnt"> 49
</span><span class="lnt"> 50
</span><span class="lnt"> 51
</span><span class="lnt"> 52
</span><span class="lnt"> 53
</span><span class="lnt"> 54
</span><span class="lnt"> 55
</span><span class="lnt"> 56
</span><span class="lnt"> 57
</span><span class="lnt"> 58
</span><span class="lnt"> 59
</span><span class="lnt"> 60
</span><span class="lnt"> 61
</span><span class="lnt"> 62
</span><span class="lnt"> 63
</span><span class="lnt"> 64
</span><span class="lnt"> 65
</span><span class="lnt"> 66
</span><span class="lnt"> 67
</span><span class="lnt"> 68
</span><span class="lnt"> 69
</span><span class="lnt"> 70
</span><span class="lnt"> 71
</span><span class="lnt"> 72
</span><span class="lnt"> 73
</span><span class="lnt"> 74
</span><span class="lnt"> 75
</span><span class="lnt"> 76
</span><span class="lnt"> 77
</span><span class="lnt"> 78
</span><span class="lnt"> 79
</span><span class="lnt"> 80
</span><span class="lnt"> 81
</span><span class="lnt"> 82
</span><span class="lnt"> 83
</span><span class="lnt"> 84
</span><span class="lnt"> 85
</span><span class="lnt"> 86
</span><span class="lnt"> 87
</span><span class="lnt"> 88
</span><span class="lnt"> 89
</span><span class="lnt"> 90
</span><span class="lnt"> 91
</span><span class="lnt"> 92
</span><span class="lnt"> 93
</span><span class="lnt"> 94
</span><span class="lnt"> 95
</span><span class="lnt"> 96
</span><span class="lnt"> 97
</span><span class="lnt"> 98
</span><span class="lnt"> 99
</span><span class="lnt">100
</span><span class="lnt">101
</span><span class="lnt">102
</span><span class="lnt">103
</span><span class="lnt">104
</span><span class="lnt">105
</span><span class="lnt">106
</span><span class="lnt">107
</span><span class="lnt">108
</span><span class="lnt">109
</span><span class="lnt">110
</span><span class="lnt">111
</span><span class="lnt">112
</span><span class="lnt">113
</span><span class="lnt">114
</span><span class="lnt">115
</span><span class="lnt">116
</span><span class="lnt">117
</span><span class="lnt">118
</span><span class="lnt">119
</span><span class="lnt">120
</span><span class="lnt">121
</span><span class="lnt">122
</span><span class="lnt">123
</span><span class="lnt">124
</span><span class="lnt">125
</span><span class="lnt">126
</span><span class="lnt">127
</span><span class="lnt">128
</span><span class="lnt">129
</span><span class="lnt">130
</span><span class="lnt">131
</span><span class="lnt">132
</span><span class="lnt">133
</span><span class="lnt">134
</span><span class="lnt">135
</span><span class="lnt">136
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">#include &lt;unistd.h&gt;
</span></span><span class="line"><span class="cl">#include &lt;stdlib.h&gt;
</span></span><span class="line"><span class="cl">#include &lt;stdio.h&gt;
</span></span><span class="line"><span class="cl">#include &lt;errno.h&gt;
</span></span><span class="line"><span class="cl">#include &lt;fcntl.h&gt;
</span></span><span class="line"><span class="cl">#include &lt;string.h&gt;
</span></span><span class="line"><span class="cl">#include &lt;sys/file.h&gt;
</span></span><span class="line"><span class="cl">#include &lt;wait.h&gt;
</span></span><span class="line"><span class="cl">#include &lt;sys/mman.h&gt;
</span></span><span class="line"><span class="cl">#include &lt;sys/stat.h&gt;
</span></span><span class="line"><span class="cl">#include &lt;semaphore.h&gt;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">#define COUNT 100
</span></span><span class="line"><span class="cl">#define SHMPATH &#34;/shm&#34;
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">static sem_t *sem;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">void mylock_init(void)
</span></span><span class="line"><span class="cl">{
</span></span><span class="line"><span class="cl">    sem_init(sem, 1, 1);
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">void mylock_destroy(sem_t *sem)
</span></span><span class="line"><span class="cl">{
</span></span><span class="line"><span class="cl">    sem_destroy(sem);
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">int mylock(sem_t *sem)
</span></span><span class="line"><span class="cl">{
</span></span><span class="line"><span class="cl">    while (sem_wait(sem) &lt; 0) {
</span></span><span class="line"><span class="cl">        if (errno == EINTR) {
</span></span><span class="line"><span class="cl">            continue;
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">        perror(&#34;sem_wait()&#34;);
</span></span><span class="line"><span class="cl">        return -1;
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    return 0;
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">int myunlock(sem_t *sem)
</span></span><span class="line"><span class="cl">{
</span></span><span class="line"><span class="cl">    if (sem_post(sem) &lt; 0) {
</span></span><span class="line"><span class="cl">        perror(&#34;semop()&#34;);
</span></span><span class="line"><span class="cl">        return -1;
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">int do_child(char * shmpath)
</span></span><span class="line"><span class="cl">{
</span></span><span class="line"><span class="cl">    int interval, shmfd, ret;
</span></span><span class="line"><span class="cl">    int *shm_p;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    shmfd = shm_open(shmpath, O_RDWR, 0600);
</span></span><span class="line"><span class="cl">    if (shmfd &lt; 0) {
</span></span><span class="line"><span class="cl">        perror(&#34;shm_open()&#34;);
</span></span><span class="line"><span class="cl">        exit(1);
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    shm_p = (int *)mmap(NULL, sizeof(int), PROT_WRITE|PROT_READ, MAP_SHARED, shmfd, 0);
</span></span><span class="line"><span class="cl">    if (MAP_FAILED == shm_p) {
</span></span><span class="line"><span class="cl">        perror(&#34;mmap()&#34;);
</span></span><span class="line"><span class="cl">        exit(1);
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">    /* critical section */
</span></span><span class="line"><span class="cl">    mylock(sem);
</span></span><span class="line"><span class="cl">    interval = *shm_p;
</span></span><span class="line"><span class="cl">    interval++;
</span></span><span class="line"><span class="cl">    usleep(1);
</span></span><span class="line"><span class="cl">    *shm_p = interval;
</span></span><span class="line"><span class="cl">    myunlock(sem);
</span></span><span class="line"><span class="cl">    /* critical section */
</span></span><span class="line"><span class="cl">    munmap(shm_p, sizeof(int));
</span></span><span class="line"><span class="cl">    close(shmfd);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    exit(0);
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">int main()
</span></span><span class="line"><span class="cl">{
</span></span><span class="line"><span class="cl">    pid_t pid;
</span></span><span class="line"><span class="cl">    int count, shmfd, ret;
</span></span><span class="line"><span class="cl">    int *shm_p;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    sem = (sem_t *)mmap(NULL, sizeof(sem_t), PROT_WRITE|PROT_READ, MAP_SHARED|MAP_ANONYMOUS, -1, 0);
</span></span><span class="line"><span class="cl">    if ((void *)sem == MAP_FAILED) {
</span></span><span class="line"><span class="cl">        perror(&#34;mmap()&#34;);
</span></span><span class="line"><span class="cl">        exit(1);
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    mylock_init();
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    shmfd = shm_open(SHMPATH, O_RDWR|O_CREAT|O_TRUNC, 0600);
</span></span><span class="line"><span class="cl">    if (shmfd &lt; 0) {
</span></span><span class="line"><span class="cl">        perror(&#34;shm_open()&#34;);
</span></span><span class="line"><span class="cl">        exit(1);
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    ret = ftruncate(shmfd, sizeof(int));
</span></span><span class="line"><span class="cl">    if (ret &lt; 0) {
</span></span><span class="line"><span class="cl">        perror(&#34;ftruncate()&#34;);
</span></span><span class="line"><span class="cl">        exit(1);
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    shm_p = (int *)mmap(NULL, sizeof(int), PROT_WRITE|PROT_READ, MAP_SHARED, shmfd, 0);
</span></span><span class="line"><span class="cl">    if (MAP_FAILED == shm_p) {
</span></span><span class="line"><span class="cl">        perror(&#34;mmap()&#34;);
</span></span><span class="line"><span class="cl">        exit(1);
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    *shm_p = 0;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    for (count=0;count&lt;COUNT;count++) {
</span></span><span class="line"><span class="cl">        pid = fork();
</span></span><span class="line"><span class="cl">        if (pid &lt; 0) {
</span></span><span class="line"><span class="cl">            perror(&#34;fork()&#34;);
</span></span><span class="line"><span class="cl">            exit(1);
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        if (pid == 0) {
</span></span><span class="line"><span class="cl">            do_child(SHMPATH);
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    for (count=0;count&lt;COUNT;count++) {
</span></span><span class="line"><span class="cl">        wait(NULL);
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    printf(&#34;shm_p: %d\n&#34;, *shm_p);
</span></span><span class="line"><span class="cl">    munmap(shm_p, sizeof(int));
</span></span><span class="line"><span class="cl">    close(shmfd);
</span></span><span class="line"><span class="cl">    shm_unlink(SHMPATH);
</span></span><span class="line"><span class="cl">    sleep(3000);
</span></span><span class="line"><span class="cl">    mylock_destroy(sem);
</span></span><span class="line"><span class="cl">    exit(0);
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p><big><strong>小结</strong></big></p>
<ol>
<li>Linux实现了 XSI 和 POSIX 两种信号量编程，其中 POSIX 还分命名和匿名之分；</li>
<li>POSIX信号量实现相比XSI更清晰简洁。在XSI信号量中，对计数器的加和减操作都是通过semop方法和一个sembuff的结构体来实现的，但是在POSIX中则给出了更清晰的定义：使用sem_post函数可以增加信号量计数器的值，使用sem_wait可以减少计数器的值。如果计数器的值当前是0，则sem_wait操作会阻塞直到值大于0。</li>
</ol>

    </div>

    
<footer class="post-footer">
      
      <nav class="post-nav">
        <a class="prev" href="/post/linux-%E5%A4%9A%E8%BF%9B%E7%A8%8B%E7%BC%96%E7%A8%8B%E6%80%BB%E7%BB%93/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">Linux 多进程编程总结</span>
            <span class="prev-text nav-mobile">Prev</span>
          </a>
        <a class="next" href="/post/linux-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-%E9%94%81/">
            <span class="next-text nav-default">Linux 多线程并发编程 &amp; 锁</span>
            <span class="next-text nav-mobile">Next</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
  <a href="http://blog.gongchang.me/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    Powered by <a class="hexo-link" href="https://gohugo.io">Hugo</a>
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    Theme - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2017 - 
    2022<span class="heart"><i class="iconfont icon-heart"></i></span><span>olOwOlo</span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script><script></script><script src="https://cdn.jsdelivr.net/npm/raphael@2.2.7/raphael.min.js" integrity="sha256-67By+NpOtm9ka1R6xpUefeGOY8kWWHHRAKlvaTJ7ONI=" crossorigin="anonymous"></script> <script src="https://cdn.jsdelivr.net/npm/flowchart.js@1.8.0/release/flowchart.min.js" integrity="sha256-zNGWjubXoY6rb5MnmpBNefO0RgoVYfle9p0tvOQM+6k=" crossorigin="anonymous"></script><script></script><script src="https://cdn.jsdelivr.net/npm/webfontloader@1.6.28/webfontloader.js" integrity="sha256-4O4pS1SH31ZqrSO2A/2QJTVjTPqVe+jnYgOWUVr7EEc=" crossorigin="anonymous"></script> <script src="https://cdn.jsdelivr.net/npm/snapsvg@0.5.1/dist/snap.svg-min.js" integrity="sha256-oI+elz+sIm+jpn8F/qEspKoKveTc5uKeFHNNVexe6d8=" crossorigin="anonymous"></script> <script src="https://cdn.jsdelivr.net/npm/underscore@1.8.3/underscore-min.js" integrity="sha256-obZACiHd7gkOk9iIL/pimWMTJ4W/pBsKu+oZnSeBIek=" crossorigin="anonymous"></script> <script src="https://cdn.jsdelivr.net/gh/bramp/js-sequence-diagrams@2.0.1/dist/sequence-diagram-min.js" integrity="sha384-8748Vn52gHJYJI0XEuPB2QlPVNUkJlJn9tHqKec6J3q2r9l8fvRxrgn/E5ZHV0sP" crossorigin="anonymous"></script>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/bramp/js-sequence-diagrams@2.0.1/dist/sequence-diagram-min.css" integrity="sha384-6QbLKJMz5dS3adWSeINZe74uSydBGFbnzaAYmp+tKyq60S7H2p6V7g1TysM5lAaF" crossorigin="anonymous">



<script type="text/javascript" src="/js/main.min.4ae89da218555efa0e7093a20b92017d2e1202b66fff9fc2edf4cb8d44b44c6e.js"></script>








</body>
</html>
